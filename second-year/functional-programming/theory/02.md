## Чистое $\lambda$-исчисление. $\lambda$-термы, свободные и связанные переменные. Классические комбинаторы, комбинаторная логика

### Термы

_Термы бестипового лямбда-исчисления_, множество которых мы будем обозначать $\Lambda$, определяются индуктивно:

$
x \in V \Rightarrow x \in \Lambda \\
M, N  \in \Lambda \Rightarrow (M\ N)  \in \Lambda \\
M \in \Lambda, x\in V \Rightarrow (\lambda x. M)  \in \Lambda
$

В абстрактном синтаксисе:

$\Lambda ::= V | (\Lambda \Lambda) | (\lambda V. \Lambda)$

Здесь $V$ — бесконечное множество переменных; его элементами будем считать латинские буквы в нижнем регистре, возможно снабженные индексами. При этом произвольные термы будем обозначать буквами латинского алфавита в верхнем регистре, как в приведенном выше определении.

Kюбой терм строятся из более простых термов в соответствии с индуктивным определением. Эти более простые термы называют _собственными подтермами данного терма_. Отношение «быть подтермом» удобно сделать рефлексивным, включив в него еще и сам анализируемый терм. Про него говорят, что он является (для самого себя) несобственным подтермом. Более формально, множество $\text{subterms}(Q)$ подтермов терма Q определяется индуктивно:

$
\text{subterms}(x) = \{x\},\\
\text{subterms}(M\ N) = {M N} \cup \text{subterms}(M) ∪ \text{subterms}(N)\\
\text{subterms}(\lambda x. M)  = {\lambda x.M} ∪ \text{subterms}(M)
$

### Соглашения

Будем придерживаться стандартных соглашений:

- внешние скобки и скобки вокруг тела лямбда-абстракции опускаются;
- операция применения термов ассоциативна влево;
- aбстракция ассоциативна вправо: $\lambda x y z. M обозначает (\lambda x.\ (\lambda y.\ (\lambda z.\ (M))))$
- тело лямбда-абстракции простирается вправо насколько это возможно;
- несколько последовательных абстракций объединяют в один блок. То есть, например, $\lambda x y. x y (z q)$ — компактное обозначение для $(\lambda x.\ (\lambda y.\ ((x y) (z q))))$.

### Редукция как правило вычислений (неформально)

На термах задают вычислительное правило $\beta$-редукции

$
(\lambda x. M) N \rightarrow_\beta [x \rightarrow N]\ M
$

где $[x \rightarrow N]\ M$ обозначает подстановку $N$ вместо $x$ в $M$.

- Применение вида $(\lambda x. M) N$, в которой левый аппликанд является _абстракцией_, называют $\beta$-_редексом_.
- Шаг вычисления по приведенному выше правилу
называют _сокращением редекса_.
- В чистом $\lambda$-исчислении нет ничего кроме переменных, применения, абстракции и $\beta$-редукции.

### Свободные и связанные переменные 

Пусть в терме $Q$ есть подтерм-переменная $x$. Говорят, что абстракция $\lambda x. Q$ _связывает дотоле свободную переменную $x$ в терме_ $Q$.Например, в терме $(\lambda y.\ (\lambda x.xz)\ y)\ w$
переменные $x$ и $y$ — _связанные_, а $z$ и $w$ — _свободные_.

Более формально, множество $FV(Q)$ _свободных (free) переменных_ в терме $Q$ определяется индуктивно

$
FV(x) = {x}, \\
FV(M N) = FV(M) \cup FV(N), \\
FV(\lambda x. M) = FV(M) \ \{x\}.
$

Множество $BV(Q)$ _связанных (bound) переменных_ в терме $Q$:

$
BV(x) = \varnothing, \\
BV(M N) = BV(M) \cup BV(N),\\
BV(\lambda x. M) = BV(M) \cup \{x\}.
$

Связывание переменной ограничивает ее область видимости
телом лямбды. Поэтому вне тела лямбды то же самое имя
может связываться повторно.

$
(\lambda x.(\lambda x.xz)x)x
$

Переменная $x$ — связанная (дважды) и свободная, а $z$ — свободная.

### Комбинаторы

$M$ – замкнутый $\lambda$-терм (или комбинатор), если
$FV(M) = \varnothing$. Множество замкнутых $\lambda$-термов обозначается $\Lambda^0$.

Многим комбинаторам даны общепринятые имена:

$
\mathbf{I} = \lambda x. x \\
\mathbf{\omega} = \lambda x. x x \\
\mathbf{\Omega} = \mathbf{\omega} \mathbf{\omega} = (\lambda x. x x)(\lambda x. x x) \\
\mathbf{K} = \lambda x y. x \\
\mathbf{K}_* = \lambda x y. y \\
\mathbf{C} = \lambda f x y. f y x \\
\mathbf{C} = \lambda f g x. f (g x) \\
\mathbf{S} = \lambda f g x. f x (g x) \\
$

### Переименование связанных переменных

Имена связанных переменных не важны; их можно (почти)
безболезненно переименовывать:

$
\mathbf{I} = \lambda x. x = \lambda y. y = \lambda z. z \\
\mathbf{B} = \lambda f g x. f (g x) = \lambda u v z. u (v z)
$

Это верно в том смысле, что термы с переименованиями при
вычислениях дают один и тот же результат:

$
(\lambda x. x) N \rightarrow_\beta N \\
(\lambda y. y) N \rightarrow_\beta N \\
(\lambda z. z) N \rightarrow_\beta N
$

Термы, отличающиеся только именами связанных переменных,
называют $\alpha$-эквивалентными.

### Комбинаторная логика

Комбинаторы можно определить как примитивы, задав их
вычислительное поведение на аргументах-переменных
Классические комбинаторы

$
\mathbf{I}\ x = x \\
\mathbf{\omega}\ x = x x \\
\mathbf{K}\ x\ y = x \\
\mathbf{S}\ f\ g\ x = f x (g x)
$

Вычисление опять задается подстановкой определения с
заменой формальных аргументов на фактические

$
ω I → I I → I.
$

Можно выбрать конечный базис. Достаточно S и K, чтобы
получить исчисление, эквивалентное $\lambda$ -исчислению.
