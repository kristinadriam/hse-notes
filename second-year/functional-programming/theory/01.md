## Сравнение функционального и императивного подходов к программированию. Функциональная модель вычислений

### Императивное программирование

Вычисление описывается в терминах _инструкций_, изменяющих
состояние _вычислителя_.

Императивный вычислитель:

- исполняет инструкции последовательно: `C1; C2; C3`;
- изменяет состояние, следуя инструкциям присваивания значений изменяемым переменным: `v = value`;
- понимает механизмы условного исполнения и циклов:
- инструкции `if`, `switch`, `for`, `while`;
- завершает вычисление, когда достигается последняя инструкция.

Такую модель вычислений иногда называют _Sequential Model of
Computation_.

```
x = 2 * x + 3;
```

Программа это _выражение_, её выполнение – _вычисление (редукция)_ этого выражения.

*Функциональный вычислитель:*

- находит в выражении редексы, то есть подвыражения,
которые могут быть вычислены непосредственно;
- выполняет сокращения редексов по заданным правилам вычислений, обычно выраженным в терминах подстановки;
- завершает вычисление, когда редексов не остается.

Пусть вычислитель умеет складывать и умножать.

$
2 * 7 + 3 \rightarrow_∗ 14 + 3 \rightarrow_+ 17
$

- На каждом шаге редекс всего один.
- В процессе вычисления могут возникать новые редексы.

### Связывание

Символ равенства (=) в ФП задает не присваивание, а
_связывание_.

```haskell
z = 2 * 7 + 3
```

- Имя слева связывается с выражением справа, порождая пользовательское вычислительное правило.
- Этим правилом можно пользоваться при вычислениях наряду со встроенными, `z` в выражениях теперь является
редексом

$
z * 4 + 1 \rightarrow_z \\
(2 * 7 + 3) * 4 + 1 \rightarrow_* \\
(14 + 3) * 4 + 1 → ... → 69
$

Иногда связывание называют равенством-по-определению
_(deﬁnitional equality)_.

Такой пример допустим и в функциональных языках

```haskell
x = 2 * x + 3

```

Но его смысл совершенно другой, это _рекурсивное
связывание_. Вычисления по этому правилу расходятся, поскольку не
содержат терминирующего условия:

$
x  *5 \rightarrow_x \\
(2 * x + 3) * 5 \rightarrow_x
(2 * (2 * x + 3) + 3) * 5 \rightarrow_x \\
(2 * (2 * (2 * x + 3) + 3) + 3) * 5 \rightarrow_x ...
$

_Рекурсивное связывание_ – мощный, но опасный
инструмент.

### Функции

Выражение `2 * y + 3` не содержит редексов, если для y нет вычислительного правила. Но при подстановке конкретного числа вместо абстрактного y редекс появится.

Следующее выражение представляет собой анонимную _функцию_ или _лямбда-абстракцию_:

```haskell
\y -> 2 * y + 3
```

Справа от стрелки (`->`) находится _тело_, а между лямбдой (`\`) и
стрелкой _ _абстрактор_.

Синтаксис применения функции к фактическому аргументу

```haskell
(\y -> 2 * y + 3) 7
(\y -> 2 * y + 3) (4 + 6)
```

Скобки применяются исключительно для группировки.

### $\beta$-редукция

Выражение, в котором анонимная функция применяется к фактическому аргументу, называется $\beta$-_редексом_.

Вычислительное правило, заключающееся в подстановке в тело лямбда-абстракции фактического значения аргумента вместо
формального называется $\beta$-_редукцией_.

$
(\setminus y -> 2 * y + 3)\ 7 \rightarrow_\beta 2 * 7 + 3 \rightarrow_∗ 14 + 3 \rightarrow_+ 17
$

Связывание позволяет закодировать именованную функцию

```haskell
foo = \y -> 2 * y + 3
```

Пример использования

$
\text{foo } 7 \rightarrow_{\text{foo}} (\setminus y -> 2 * y + 3)\ 7 \rightarrow_\beta ... → 17
$

### Стратегии редукции

```haskell
(\y -> 2 * y + 3) (4 + 6) → ???
```

Ой. А тут два редекса. Какой сокращать?

В Haskell используют _ленивую стратегию_, сокращая самый левый внешний редекс:

$
(\setminus y -> 2 * y + 3)\ (4 + 6) \rightarrow_\beta 2 * (4 + 6) + 3 \rightarrow_+
2 * 10 + 3 \rightarrow_∗ 20 + 3 \rightarrow_+ 23
$

В языках семейства ML используют _энергичную стратегию_:

$
(\setminus y -> 2 * y + 3)\ (4 + 6) →+ (\setminus y -> 2 * y + 3)\ 10 \rightarrow_\beta
2 * 10 + 3 \rightarrow_∗ 20 + 3 \rightarrow_+ 23
$

#### Пример

Теперь можем рекурсивно определить не константу, а функцию

```haskell
fact = \n -> if n == 0 then 1 else n * fact (n-1)
```
Пример ленивого вычисления выражения `fact 3`
```haskell
fact 3 
```

$\rightarrow_{\text{fact}}$

```haskell
(\n -> if n == 0 then 1 else n * fact (n-1)) 3 
```

$\rightarrow_{\beta}$

```haskell
if 3 == 0 then 1 else 3 * fact (3-1)
```

$\rightarrow_{==}$

```haskell
if False then 1 else 3 * fact (3-1) 
```

$\rightarrow_{\text{if}}$

```haskell
3 * fact (3-1) 
```

$\rightarrow_{\text{fact}}$

```haskell
3 * if (3-1) == 0 then 1 else (3-1) * fact ((3-1)-1) 
```

$\rightarrow_{-}$

```haskell
...
3 * (2 * (1 * if (((3-1)-1)-1) == 0 then 1 else ...)) 
```

$\rightarrow_{-}... 3 * (2 * (1 * 1)) \rightarrow_∗ ... \rightarrow_∗ 6$

Реализация может быть эффективнее, но «подстановочная» семантика должна сохраняться.

### Функции нескольких переменных

Выражение `2 * m + 3 * n` содержит две переменные. Абстракция по одной из них вносит асимметрию

```haskell
\n -> 2 * m + 3 * n
```

Продолжая абстракцию, получим _замкнутое_ выражение

```haskell
\m -> (\n -> 2 * m + 3 * n)
```

Вычисление требует последовательной передачи аргументов

$
((\setminus m -> (\setminus n -> 2 * m + 3 * n))\ 15)\ 4 \rightarrow_\beta \\
(\setminus n -> 2 * 15 + 3 * n) 4 \rightarrow_\beta \\
2 * 15 + 3 * 4 \rightarrow ... \rightarrow 42
$

Такие функции называют _каррированными_.
Внутренний редекс иллюстрирует понятие _частичного применения_ каррированной функции.

### Сильные стороны ФП

- Регулярный и лаконичный синтаксис.
- Мощная типизация, необременительная благодаря эффективным алгоритмам вывода типов.
- Эффективная доказуемость свойств программ алгебраическими методами.
- Возможность генерации программ по набору свойств.
- Высокоуровневые оптимизации на базе эквивалентных преобразований.
