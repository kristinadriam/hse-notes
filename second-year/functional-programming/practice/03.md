## 3. Операторы и их сечения в Haskell

Оператор — это комбинация из одного или более символов

```haskell
! # $ % & * + . / < > ? @ ^ | - ~ = \ :
```

Все операторы бинарные и инфиксные, то есть выражение `(u <*?*> v)` представляет собой применение оператора `<*?*>` к двум аргументам `u` и `v`.

Исключением служит унарный префиксный минус, который всегда ссылается на `Prelude.negate`, то есть выражение (`- x`) транслируется в `negate x`. Еще одним специальным случаем служит символ `:` (двоеточие). Если он является первым символом оператора, то такой оператор должен быть инфиксным конструктором данных и объявляться как часть определения типа данных.

В отличие от ряда других языков, где набор операторов фиксирован, в Haskell их можно задать сколь угодно много.

Определение оператора похоже на определение функции, но идентификатор оператора в левой части определения используется инфиксно. Например, определив оператор `*+*` для суммы квадратов:

```haskell
a *+* b = a ^ 2 + b ^ 2

ghci> 3 *+* 4  
25
```

Операторы могут определяться и использоваться в _префиксном (функциональном) стиле_. Для этого имя оператора нужно заключить в круглые скобки. Например, определим префиксно оператор для суммы кубов. Мы При этом мы можем использовать его (как и любой другой оператор) и в инфиксном и в префиксном стиле.

### пример

```haskell
(**+**) a b = a ^ 3 + b ^ 3

ghci> (**+**) 2 3
35
ghci> 2 **+** 3
35
ghci> (*+*) 4 3
25
```

Функции, в свою очередь, могут определяться и использоваться в_инфиксном (операторном) стиле_. Для этого мы должны заключить имя функции в обратные кавычки:

```haskell
x `plusminus` y = (x + y, x - y)
```

### Приоритет и ассоциативность

Инфиксные операторы требуют определения

* приоритета: какой оператор из цепочки выполнять первым;
* ассоциативности: какой оператор из цепочки выполнять первым при равном приоритете.
Если не заданы, присваивается `infixl 9`.

В Haskell приоритет и ассоциативность задают с помощью _объявлений фиксности (fixity declaration)_ `infixl`, `infixr` или `infix`. Например:

```haskell
infixl 6 *+*, **+**
infix 5 `plusminus`
```

### Стандартные библиотечные операторы

В Haskell довольно большое число операторов описано в стандарте языка; еще большее их число реализовано в стандартных библиотеках, поставляющихся с GHC.
Ниже приведены приоритет операторов и функций из Haskell Report.

```haskell
infixl 9 !!
infixr 9 .
infixr 8 ^, ^^, **
infixl 7 *, /, `quot`, `rem`, `div`, `mod`
infixl 6 +, -
infixr 5 ++, :
infix  4 ==, /=, <, <=, >=, >, `elem`, `notElem`
infixr 3 &&
infixr 2 ||
infixl 1 >>, >>=
infixr 1 =<<
infixr 0 $, $!, `seq`
--применение имеет десятый приоритет
```

Есди вы хотите выяснить приоритет какого-то оператора, то это можно сделать в GHCi, набрав `:info`.

```haskell
ghci> :info &&
(&&) :: Bool -> Bool -> Bool    -- Defined in `GHC.Classes'
infixr 3 &&
```

### Оператор `$`

Оператор `($)` задаёт применение функции к аргументу, фактически делая явным
упомянутый выше «оператор» пробел:

```haskell
infixr 0 $ 
f $ x = f x
```

На первый взгляд его смысл не очевиден. Действительно, зачем заменять пробел на другой значок? Однако тот факт, что его приоритет установлен наименьшим из возможных, позволяет использовать его для элиминации избыточных скобок

```haskell
f (g x) ≡ f $ g x
f (g x (h y)) ≡ f $ g x (h y) ≡ f $ g x $ h y
```

Из второго примера ясна причина правоассоциативности этого оператора. Также оператор `($)` используют для передачи применения в функции высших порядков.

### Оператор `&`

Этот оператор разворачивает конвейер вычислений

```haskell
infixl 1 & -- Data.Function
(&) :: a -> (a -> b) -> b
(&) = flip ($)

ghci> (+12) $ (*10) $ 3
42
ghci> 3 & (*10) & (+12)
42
```

### Оператор `(.)`

Оператор `(.)` задаёт композицию функций.

```haskell
infixr 9 .
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \ x -> f (g x)
```

Например, выражение `(^2) . (+5)` – это функция, прибавляющая `5` к своему аргументу, а затем возводящая результат в квадрат:

```haskell
ghci> (^2) . (+5) $ 1
36
ghci> (^2) . (+5) $ 2
49
```

### Cечения

Операторы на самом деле просто функции и, поэтому, допускают частичное применение. Есть дополнительный синтаксический сахар, обеспечивающий возможность записать частичное применение оператора как к левому, так и к правому своему аргументу.

_Левое сечение (left section)_ оператора `(*+*)` записывается так `(2 *+*)` и эквивалентно обычному частичному применению этого оператора, приведенного к функциональному стилю:

``` haskell
(2 *+*) ≡ (*+*) 2 ≡ \y -> 2 *+* y
```

_Правое сечение (right section)_ связывает правый аргумент оператора, то есть второй, если перевести оператор в функциональный стиль. Записать это в виде частичного применения невозможно, в виде лямбды это выглядит так

``` haskell
(*+* 3) ≡ \x -> x *+* 3
```

Скобки являются неотъемлемой частью синтаксиса сечений, их наличие обязательно.

```haskell
ghci> :t (!!)
(!!) :: [a] -> Int -> a
ghci> :t (!! 0)
(!! 0) :: [a] -> a
```
