## 2. Основные встроенные типы языка Haskell. Параметрический полиморфизм. Система модулей

### Базовые типы

* `Bool` — булево значение;
* `Char` — символ Юникода;
* `Int`, `Integer` — целые числа фиксированной и неограниченной разрядности;
* `Float`, `Double` — числа с плавающей точкой одинарной и двойной точности;
* `type1 -> type2` — тип функции с аргументом типа `type1` и возвращаемым значением типа `type2`;
* `(type1, type2, ..., typeN)` — тип кортежа, `N>1`;
* `()` — единичный тип, с одной константой ();
* `[type1]` — тип списка с элементами типа `type1`

Имя конкретного типа, как встроенного так и пользовательского, должно начинаться с символа в верхнем регистре. Оператор `(::)` используется для связывания выражения и его типа. В ghci для выяснения типа выражения используют команду `:type`.

```haskell
ghci> :type True
True :: Bool
ghci> :type 'z'
'z' :: Char
```

Хотя Haskell умеет выводить типы, программист может явно указывать желаемый тип выражения:

```haskell
ghci> :t (sin pi :: Double)
(sin pi :: Double) :: Double
ghci> :t (42 :: Integer)
(42 :: Integer) :: Integer
```

Типы списка, кортежа и функции можно записывать не только в определенной выше миксфиксной и инфиксной нотации, но и в префиксной:

```haskell
ghci> [1,2,3] :: [Double]
[1.0,2.0,3.0]
ghci> [1,2,3] :: [] Double
[1.0,2.0,3.0]
ghci> (1,'z',True) :: (Int,Char,Bool)
(1,'z',True)
ghci> (1,'z',True) :: (,,) Int Char Bool
(1,'z',True)
ghci> (,,) 1 'z' True :: (,,) Int Char Bool
(1,'z',True)
ghci> :t (,,) 1 'z' True :: (,,) Int Char Bool
(,,) 1 'z' True :: (,,) Int Char Bool :: (Int, Char, Bool)
ghci> :t (\x -> x) :: Char -> Char
(\x -> x) :: Char -> Char :: Char -> Char
ghci> :t (\x -> x) :: (->) Char Char
(\x -> x) :: (->) Char Char :: Char -> Char
```

Типы, записанные в префиксной нотации, являются полными синонимами обычных инфиксных и миксфиксных вариантов. Префиксная нотация полезна, поскольку позволяет применять для встроенных типов многие механизмы доступные для пользовательских, которые определяются префиксно. Например, с помощью префиксной нотации удобно задавать частичное применение типов.

### Устройство и использование типов

Основным способом объявлять _пользовательские типы данных (user-defined datatypes declaration)_ является объявление `data`. Например, стандартный булев тип представляет собой _перечисление (enumeration)_, определяемое следующим образом

```haskell
data Bool = True | False
```

Присутствующее в левой части равенства идентификатор `Bool` называется _конструктором типа_, а присутствующие справа `True` и `False` называются _конструкторами данных_. Имена пользовательских конструкторов должны начинаться с символа в верхнем регистре.

Каковы методы работы с подобными типами данных? При определении функции мы можем в качестве формальных аргументов использовать не только переменные, но и образцы. Мы видели это раньше на примере функций над встроенным типом кортежа, например `fst (x,y) = x`.

На самом деле _образец_ с технической точки зрения — это конструктор данных, расположенный не в правой части связывания, а в левой. Поскольку у типа `Bool` два взаимоисключающих конструктора данных, то для определения полновесной функции над этим типом нужно задать два равенства:

```haskell
not       :: Bool -> Bool
not True  = False
not False = True
```

При вызове функции происходит _сопоставление с образцом_: выбирается то равенство, которое соответствует фактически переданному аргументу. Если в качестве аргумента передается не значение, а выражение, то, несмотря на ленивую природу языка, вычисление этого выражения форсируется. Это оправдано, поскольку иначе невозможно выбрать подходящее равенство, а значит невозможно продолжить вычисление. Именно этот механизм обеспечивает расходимость функции

```haskell
bot :: Bool
bot = not bot
```

Отметим, что мы начали сопровождать определения функций глобальными _объявлениями сигнатуры типа (type signature declaration)_: `not :: Bool -> Bool, bot :: Bool`. Это необязательно (тайпчекер умеет выводить эти типы), но приветствуется. Такие объявления работают как верифицируемая тайпчекером документация.

### Тип функции нескольких переменных

Каков тип можно приписать функции нескольких переменных? Вспомним функцию двух переменных

```haskell
foo x y = 10 * x + y
```

Мы уже обсуждали, что ее можно интерпретировать как функцию одной переменной `x`, возвращающей функцию одной переменной `y`. Это позволяет осуществить частичное применение: `foo 4` — это функция одного аргумента, прибавляющая к нему число `40`. Отсюда естественным образом получаем, что следующий тип допустим для `foo`:

```haskell
foo :: Int -> (Int -> Int)
```

Отметим, что функциональная стрелка в определении типа `(->)` представляет собой бинарный оператор. Хотя это оператор не над выражениями языка, а над типами, разработчиками языка для него задана правая ассоциативность. Поэтому другая, более компактная и общепринятая запись объявления типа `foo` такова:

```haskell
foo :: Int -> Int -> Int
```

Отметим, что правая ассоциативность функциональной стрелки на уровне типов хорошо согласуется с левой ассоциативностью оператора применения на уровне выражений `foo 4 2 == (foo 4) 2`. Действительно:

```haskell
GHCi> :t foo 4
foo 4 :: Int -> Int
GHCi> bar = foo 4
GHCi> :t bar
bar :: Int -> Int
GHCi> bar 2
42
```

Если тип имеет несколько конструкторов данных, то функция нескольких переменных для него задается путем сопоставления с нужным для реализации этой функции числом образцов:

```haskell
(&&)           :: Bool -> Bool -> Bool
(&&) True True = True
(&&) x    y    = False
```

Полный перебор всех возможных конструкторов дал бы 4 уравнения. Это была бы допустимая, но не самая компактная реализация.

Мы видим, что допустимо вперемешку использовать в качестве формальных аргументов функций как переменные, так и конструкторы. Образцами называется и то и другое. При этом сопоставление с переменной всегда удачно.

В приведенной выше реализации второе уравнение содержит переменные `x` и `y` в левой части объявления функции. При необходимости мы могли бы использовать их при реализации правой части. Но в данном случае правая часть в них не нуждается, поэтому, чтобы не тратить впустую имена, можно использовать символ подчеркивания, называемый _джокер (wildcard)_:

```haskell
(&&)           :: Bool -> Bool -> Bool
(&&) True True = True
(&&) _    _    = False
```

### Параметрический полиморфизм

Многие из рассмотренных нами функций были определены для конкретных типов дан- ных. Однако некоторые функции не накладывают на типы своих аргументов совершенно никаких ограничений. Определим две подобные функции. Мы можем вызывать их на любых аргументах:

```haskell
i x = x
k x1 x2 = x1

GHCi> i 42
42
GHCi> i "Hello"
"Hello"
GHCi> k 'z' True
'z'
GHCi> k 'z' undefined
'z'
```

Такие функции называются _полиморфными_. Для описания типа их аргументов используют не имена конкретных типов, а переменные типа:

```haskell
GHCi> :t i
i :: p -> p
GHCi> :t k
k :: p1 -> p2 -> p1
```

Используемый здесь род полиморфизма называют _параметрическим_, поскольку переменные типа (`p`, `p1`, `p2` в примерах выше) параметризуют типовое выражение.

Применение полиморфной функции к значению конкретного типа приводит к сня- тию полиморфизма. При этом тип получившегося выражения определяется так: все вхождения конкретизируемого параметра замещаются на конкретный тип фактически переданного аргумента:

```haskell
GHCi> :t i True
i True :: Bool
GHCi> :t i 'w'
i 'w' :: Char
GHCi> :t k 'z' False
k 'z' False :: Char
```

В первых двух примерах в типе `i :: p -> p` переменная типа `p` заменяется на `Bool` и `Char` соответственно. В третьем примере в типе `k :: p1 -> p2 -> p1` происходит замена `p1` на `Char`, а `p2` на `Bool`.

При частичном применении полиморфизм снимается частично:

```haskell
GHCi> :t k 'z'
k 'z' :: p2 -> Char
GHCi> :t k "ABC"
k "ABC" :: p2 -> [Char]
```

Однако полиморфизм может сохраниться и при полном применении, если фактически переданный аргумент сам является полиморфным

```haskell
GHCi> :t i i
i i :: p -> p
```

В этом выражении типы у двух вхождений `i` разные. Правое вхождение имеет стандартный полиморфный тип `i :: p -> p`. Левое вхождение «подстраивается» по типу под правое. Поскольку у функции тип формального и фактического аргумента долж- ны совпадать, то тип левого вхождения `i :: (p -> p) -> (p -> p)`, что эквивалентно `i :: (p -> p) -> p -> p` благодаря правой ассоциативности функциональной стрелки. Применяя одно к другому получаем результат, наблюдаемый выше в сессии GHCi.

Более полное представление об работе с полиморфными типами можно получить, заглянув в реализацию системы вывода типов GHC. К счастью для знакомства с некоторыми подробностям реализации нет необходимости изучать исходный код тайпчекера. Для этого достаточно подключить два расширения. Первое `fprint-explicit-foralls` является расширением интерпретатора GHCi. Оно позволяет увидеть как на самом деле устроены полиморфные функции:

Мы видим, что на самом деле переменные типа находятся под квантором общности. Например, тип `i` читается так: «для любого типа `p` это функция из `p` в `p»`.

Такой подход делает `i` функцией не одной переменной, а двух. Мы можем отдельно управлять конкретизацией полиморфной функции, и отдельно передавать ей параметр конкретного типа. Для этого нужно подключить еще одно расширение:

```haskell
GHCi> :set -XTypeApplications
```

Теперь мы можем применять выражение не только к выражению, но и выражение к типу (отсюда название расширения). Чтобы отличать этот род применения от обычного, перед именем типа используется специальный символ `@`. Например, применить комбинатор `i` к типу `Bool`

```haskell
GHCi> :t i @Bool
i @Bool :: Bool -> Bool
```

Такое применение допустимо, только если выражение имеет полиморфный тип:

```haskell
GHCi> :t i @Bool
i @Bool :: Bool -> Bool
GHCi> :t k @Bool
k @Bool :: forall {p2}. Bool -> p2 -> Bool
GHCi> :t k @Bool @Char
k @Bool @Char :: Bool -> Char -> Bool
GHCi> :t i @Bool @Char
<interactive>: error:
    *Cannot apply expression of type `Bool -> Bool'
      to a visible type argument`Char'
    * In the expression: i @Bool @Char
```

Мономорфизированные выражения можно использовать так же как обычные:

```haskell
GHCi> i @Int 42
42
GHCi> k @Bool @Char True 'z'
True
GHCi> k @Bool @Char True False
<interactive>: error:
    *Couldn't match expected type `Char' with actual type`Bool'
    * In the fourth argument of `k', namely`False'
      In the expression: k @Bool @Char True False
      In an equation for `it': it = k @Bool @Char True False
```

Отметим, что типовые параметры типов являются неявными. Если их опустить, то они будут выведены автоматически:

```haskell
GHCi>  k @Char 'x' True
'x'
GHCi>  k @Char 'x' 42
'x'
GHCi> :t k @Char 'x'
k @Char 'x' :: forall {p2}. p2 -> Char
```

### Система модулей

Мы уже обсуждали структуру программ на Haskell. На самом «мелком» уровне мы используем выражения; более крупными строительными блоками служат объявления; и, наконец, на самом верхнем уровне программа состоит из набора _модулей_.

Для объявления модуля мы используем ключевое слово `module`, после которого идет имя модуля (начинающееся с символа в верхнем регистре):

Пример модуля

``` haskell
module Lesson1 where {
bot = 1 + bot; -- variable binding
(x,y) = ('A',21*2); -- pattern binding, x and y are global 
foo x y = 10 * x + y; -- function binding, x and y are local 
}
```

Модуль представляет собой множество объявлений. На практике все используют эквивалентный синтаксис с отступами:

``` haskell
module Lesson1 where
bot = 1 + bot -- variable binding
(x,y) = ('A',21*2) -- pattern binding, x and y are global
foo x y = 10 * x + y -- function binding, x and y are local
```

Отметим, что обычно для объявлений в глобальной области видимости используют нулевые отступы, хотя по стандарту это не обязательно.

GHC требует, чтобы каждый модуль был реализован в отдельном файле, и имя файла совпадало с именем модуля6, хотя стандарт не накладывает таких ограничений, оставляя это во власти разработчиков компилятора.

Модули позволяют задавать пространствами имён и обеспечивают инкапсуляцию через списки экспорта и импорта. Если мы хотим использовать в модуле `A` имена из модуля `B` мы должны импортировать этот модуль:

```haskell
module A where
import B
foo = qux quux
bar = ...
baz = ...
```

Объявления импорта должны быть первыми объявлениями модуля. В этом примере подразумевается, что qux и quux экспортируются из модуля `B`. По умолчанию экспортируются все имена, определенные в модуле глобально, на верхнем уровне. В частности, если кто-то будет импортировать наш модуль `A`, то ему станут доступны `foo`, `bar` и `bas`. Такое поведение может быть изменено с помощью _списка экспорта (export list)_:

```haskell
module A (foo, bar) where
import B
foo = qux quux
bar = ...
baz = ...
```

Здесь мы явно задали публичный интерфейс нашего модуля, перечислив список `(foo, bar)` экспортируемых из него имен. Функция `baz` при этом не экспортируется, оставаясь деталью реализации.

Существует также _списка импорта (import list)_. Импортируя модуль, мы явно можем указать в скобках все те имена из него, которые нам потребуются:

```haskell
module A where
import B (qux,quux)
foo = qux quux
bar = ...
baz = ...
```

Указание исчерпывающего списка импорта считается хорошим стилем программирования, поскольку оно позволяет не засорять пространство доступных имен и ускоряет компиляцию.

Одной из проблем при программировании служит ситуация конфликта имен: одно и то же имя может быть определено в разных модулях. Если мы импортируем оба, то возникает неоднозначность:

```haskell
ghci> map (\x -> x + 2) [1,2,3]
[3,4,5]
ghci> import Data.Map
ghci> map (\x -> x + 2) [1,2,3]
<interactive>: error:
    Ambiguous occurrence `map'
    It could refer to either `Prelude.map',
                           or `Data.Map.map',
```

Конфликты имён разрешаются через полные имена: они включают не только имя функции, но и имя модуля, в котором эта функция объявлена: `Prelude.map` и `Data.Map.map` уже не конфликтуют. Разделителем служит точка, пробелы вокруг нее не допускаются.

```haskell
ghci> Prelude.map (\x -> x + 2) [1,2,3]
[3,4,5]
```

Если подобный конфликт имен является массовым, можно использовать _квалифицированный импорт_:

```haskell
import qualified B (qux,quux)
foo = B.qux B.quux
```

Теперь мы застрахованы от конфликтов имен, поскольку не можем использовать имена `qux` и `quux` из модуля B без явного указания имени модуля. Такое («неквалифицированное») использование приведет к ошибке компиляции независимо от того, возникает конфликт имен или нет.

Часто при импорте модулей с длинными именами удобно использовать _псевдонимы_:

```haskell
ghci> import Data.Set as S
ghci> S.map (\x -> x + 2) (S.fromList [1,2,3])
fromList [3,4,5]
```

Во многих примерах мы импортировали модули в интерпретаторе ghci, однако точно те же правила действуют при импорте в файлах исходного кода.
