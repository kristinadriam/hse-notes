<!-- lecture from 05/09/2023 -->
# Лямбда-исчисление
## Функциональная модель вычислений

### Императивное программирование

Вычисление описывается в терминах инструкций, изменяющих состояние вычислителя.

Императивный вычислитель:
- исполняет инструкции последовательно `C1`; `C2`; `C3`; 
- изменяет состояние, следуя инструкциям присваивания значений изменяемым переменным: 

    `v = value; `
- понимает механизмы условного исполнения и циклов:
- инструкции `if`, `switch`, `for`, `while`;
- завершает вычисление, когда достигается последняя инструкция.

Такую модель вычислений иногда называют _Sequential Model of Computation_.

$\text{x} = 2 * \text{x} + 3;$

### Функциональное программирование

_Программа_ это выражение, её выполнение — вычисление _(редукция)_ этого выражения.

Функциональный вычислитель:
- находит в выражении _редексы_, то есть подвыражения, которые могут быть вычислены непосредственно;
- выполняет сокращения редексов по заданным _правилам вычислений_, обычно выраженным в терминах _подстановки_;
- завершает вычисление, когда редексов не остается. 

Пусть вычислитель умеет складывать и умножать.

$2*7+3 \rightarrow_+ 14+3 \rightarrow_+ 17$

- На каждом шаге редекс всего один.
- В процессе вычисления могут возникать новые редексы.

### Связывание
Символ равенства (`=`) в ФП задает не присваивание, а _связывание_.

$\text{z}=2*7+3$

- Имя слева связывается с выражением справа, порождая пользовательское вычислительное правило.
- Этим правилом можно пользоваться при вычислениях наряду со встроенными, $\text{z}$ в выражениях теперь является редексом

$\text{z}*4+1 \rightarrow_\text{z} (2*7+3)*4+1 \rightarrow_* (14+3)*4+1→ ...→69$

Иногда связывание называют равенством-по-определению (_definitional equality_).

- Пример с первого слайда допустим и в функциональных языках
    
    `x = 2 * x + 3`
- Но его смысл совершенно другой, это _рекурсивное связывание_.
- Вычисления по этому правилу расходятся, поскольку не содержат терминирующего условия:

    $\text{x} * 5 \rightarrow_\text{x}$

    $(2*\text{x}+3)*5 \rightarrow_\text{x}$

    $(2 * (2 * x + 3) + 3) * 5 \rightarrow_\text{x}$

    $(2*(2*(2*\text{x}+3)+3)+3)*5\rightarrow_\text{x} ...$
- Рекурсивное связывание — мощный, но опасный инструмент.

### Определение функций
Выражение `2 * y + 3` не содержит редексов, если для y нет вычислительного правила. Но при подстановке конкретного числа вместо абстрактного y редекс появится.

Следующее выражение представляет собой _анонимную функцию_ или _лямбда-абстракцию_:

`\y -> 2 * y + 3`

Справа от стрелки (`->`) находится _тело_, а между лямбдой (`\`) и стрелкой — _абстрактор_.

Синтаксис применения функции к фактическому аргументу
```
(\y -> 2 * y + 3) 7
(\y -> 2 * y + 3) (4 + 6)
```
Скобки применяются исключительно для группировки.

### Вычисление: $\beta$-редукция

Выражение, в котором анонимная функция применяется к фактическому аргументу, называется $\beta$-_редексом_. 

Вычислительное правило, заключающееся в подстановке в тело лямбда-абстракции фактического значения аргумента вместо формального называется $\beta$-_редукцией_.


`(\y -> 2 * y + 3) 7` $\rightarrow_\beta$ `2 * 7 + 3` $\rightarrow_*$ `14 + 3` $\rightarrow_+$ `17` 

Связывание позволяет закодировать именованную функцию 

`foo = \y -> 2 * y + 3`

Пример использования:

`foo 7 ` $\rightarrow_\text{foo}$ `(\y -> 2 * y + 3) 7` $\rightarrow_\beta$ ... $\rightarrow$ `17`

TODO

**Сильные стороны ФП**
- Регулярный и лаконичный синтаксис.
- Мощная типизация, необременительная благодаря эффективным алгоритмам вывода типов.
- Эффективная доказуемость свойств программ алгебраическими методами.
- Возможность генерации программ по набору свойств.
- Высокоуровневые оптимизации на базе эквивалентных преобразований.

## Чистое $\lambda$-исчисление

### Термы чистого $\lambda$-исчисления

Множество _$\lambda$-термов_ \Lambda$$ индуктивно строится из переменных $V = \{x, y, z, ...\}$ c помощью применения и абстракции:

$x\in V \Rightarrow x\in \Lambda$

$M, N\in \Lambda \Rightarrow (MN)\in \Lambda$

$M \in \Lambda, x\in V \Rightarrow (\lambda x.M)\in \Lambda$

В абстрактном синтаксисе

$\Lambda ::= V | (\Lambda\Lambda) | (\lambda V.Λ)$

**Соглашение.** Произвольные термы пишем заглавными
буквами, переменные — строчными.

**Примеры $\lambda$-термов:**

$x$

$(x z)$

$(\lambda x. (x z))$ 

$((\lambda x. (x z)) y)$

$(\lambda y. ((\lambda x. (x z)) y))$

$((\lambda y. ((\lambda x. (x z)) y)) w)$

В этом списке каждый следующий терм содержит предыдущие в качестве _подтерма_.

### Термы (соглашения)

Общеприняты следующие соглашения: 
- Внешние скобки опускаются. - Применение ассоциативно _влево_:
    
    $FXYZ$ обозначает $(((FX)Y)Z)$ 
- Абстракция ассоциативна _вправо_:
    
    $\lambda xyz.M$ обозначает $(\lambda x.(\lambda y.(\lambda z.(M))))$
- Тело абстракции простирается вправо насколько это возможно:

    $\lambda x. F X Y$ обозначает $\lambda x. (F X Y)$

**Те же примеры, что и выше, но с использованием соглашений:**

$x=x$

$(x z)= xz$

$(\lambda x. (x z))=\lambda x. x z$ 

$((\lambda x. (x z)) y)=(\lambda x. x z) y$

$(\lambda y. ((\lambda x. (x z)) y))=\lambda y. (\lambda x. x z) y$

$((\lambda y. ((\lambda x. (x z)) y)) w)=(\lambda y. (\lambda x. x z y)) w$

### Редукция как правило вычислений

- На термах задают вычислительное правило $\beta$-редукции 

$(\lambda x.M)N \rightarrow_\beta [x \mapsto N]M$

где $[x \mapsto N] M$ обозначает _подстановку_ $N$ вместо $x$ в $M$. 
- Применение вида $(\lambda x. M) N$, в которой левый аппликанд
является абстракцией, называют $\beta$-_редексом_. 
- Шаг вычисления по приведенному выше правилу
называют сокращением редекса.
- В _чистом $\lambda$-исчислении_ нет ничего кроме переменных,
применения, абстракции и $\beta$-редукции.

### Свободные и связанные переменные

Абстракция $\lambda x. M[x]$ _связывает_ дотоле _свободную_ переменную $x$ в терме $M$.

$(\lambda y.(\lambda w.wz)y)x$

Переменные $y$ и $w$ — связанные, а $z$ и $x$ — свободные.

Связывание переменной ограничивает ее область видимости телом лямбды. Поэтому вне тела лямбды то же самое имя может связываться повторно.

$(\lambda x.(\lambda x.xz)x)x$

Переменная $x$ — связанная (дважды!) и свободная, а $z$ — свободная.

Множество $\text{FV}(T)$ _свободных (free) переменных_ в терме $T$:

$\text{FV}(x) =\{x\}$ 

$\text{FV}(M N) = \text{FV}(M)\cup \text{FV}(N)$

$\text{FV}(\lambda x. M) = \text{FV}(M) \setminus \{x\}$

Множество $\text{BV}(T)$ _связанных (bound) переменных_ в терме $T$:

$\text{BV}(x) =\varnothing$ 

$\text{BV}(M N) = \text{BV}(M)\cup \text{BV}(N)$

$\text{BV}(\lambda x. M) = \text{BV}(M) \cup \{x\}$

### Комбинаторы

$M$ — замкнутый $\lambda$-терм (или комбинатор), если
$\text{FV}(M) = \varnothing$. Множество замкнутых $\lambda$-термов обозначается $\Lambda^0$.

Многим комбинаторам даны общепринятые имена:

$I =\lambda x.x$

$\omega = \lambda x.xx$
$\Omega = \omega\omega = (\lambda x.xx)(\lambda x.xx)$

$K = \lambda xy.x$

$K_∗ = \lambda xy.y$

$C = \lambda fxy.fyx$

$B = \lambda fgx.f(gx)$

$S = \lambda fgx.fx(gx)$

### Переименование связанных переменных

Имена связанных переменных не важны; их можно (почти) безболезненно переименовывать:

$I = \lambda x.x=\lambda y.y=\lambda z.z$

$B = \lambda fgx.f(gx) = \lambda uvz.u(vz)$

Это верно в том смысле, что термы с переименованиями при вычислениях дают один и тот же результат:

$(\lambda x.x)N \rightarrow_\beta N$

$(\lambda y.y)N \rightarrow_\beta N$

$(\lambda z.z)N \rightarrow_\beta N$

Термы, отличающиеся только именами связанных переменных, называют $\alpha$-_эквивалентными_.


### Комбинаторная логика

Комбинаторы можно определить как примитивы, задав их вычислительное поведение на аргументах-переменных.

**Классические комбинаторы:**

$Ix=x$

$\omega x=xx$ 

$Kxy=x$ 

$Sfgx = fx(gx)$

Вычисление опять задается подстановкой определения с заменой формальных аргументов на фактические

$\omega I \rightarrow II \rightarrow I$.

Можно выбрать конечный базис. Достаточно $S$ и $K$, чтобы получить исчисление, эквивалентное $\lambda$-исчислению.


## Подстановка и отношения редукции

Подстановка выполняется только вместо _свободных_ вхождений:

$$[x \mapsto \lambda z.z]\ (x(\lambda x.xy)x) = (\lambda z.z)\ (\lambda x.xy)(\lambda z.z)$$

Проблема _захвата переменной_ (variable capture):

$$[x \mapsto y]\ (\lambda y.xy) = \lambda y.yy$$

**Соглашение Барендрегта**

Имена связанных переменных всегда будем выбирать так, чтобы они отличались от имён свободных переменных.

Тогда коллизий, связанных с захватом, можно избежать:

$$[x \mapsto y]\ (\lambda y'.xy') = \lambda y'.yy'$$

Однако удобнее встроить переименование в определение подстановки.

**Определение подстановки $[x \mapsto N] M$**

_Подстановка_ терма $N$ вместо свободных вхождений переменной $x$ в терм $M$ задается индукцией по структуре $M$:

$[x \mapsto N] x = N$

$[x \mapsto N] y = y$

$[x \mapsto N] (PQ) = ([x \mapsto N]P)\ ([x \mapsto N]Q)$

$[x \mapsto N] (\lambda x.P) = \lambda x.P$

$[x \mapsto N] (\lambda y.P) = \lambda y.[x \mapsto N] P$, если $y\not\in \text{FV}(N)$

$[x \mapsto N] (\lambda y.P) = \lambda y'.[x \mapsto N] ([y\mapsto y']P)$, если $y\in \text{FV}(N)$

Подразумевается, что $x$ отлично от $y$, а $y'$ — свежая, то есть $y'\not\in \text{FV}(N)\cup \text{FV}(P)$.

### Лемма подстановки

Подстановки не коммутируют. Однако верна

**Лемма подстановки:**

Пусть $M, N, L \in \Lambda$. Предположим $x\not\equiv  y$ и $x \not \in \text{FV}(L)$. Тогда 

$[y \mapsto L]\ ([x \mapsto N]M) \equiv [x \mapsto [y \mapsto L]N]\ ([y \mapsto L]M)$.


**Доказательство:**

Нудная индукция по всем 6 случаям, с разбором всех подслучаев.
### Отношение $\beta$-редукции за один шаг

Бинарное отношение $\mathcal{R}$ над $\Lambda$ называют _совместимым_, если
для любых $M, N, Z \in \Lambda$ и любой переменной $x$

$$
M\ \mathcal{R}\ N \Rightarrow \mathcal{Z}\ M\  \mathcal{R}\ \mathcal{Z}\ N
\\
M\ \mathcal{R}\ N \Rightarrow M\ \mathcal{Z} \  \mathcal{R}\ N\ \mathcal{Z}
\\
M\ \mathcal{R}\ N \Rightarrow \lambda x.M \ \mathcal{R}\ \lambda x.N
$$

Наименьшее совместимое отношение $\rightarrow_\beta$, удовлетворяющее 

$(\lambda x. M)N \rightarrow_\beta [x \mapsto N] M $ (правило $\beta$)

называется _отношением $\beta$-редукции_.

$(\lambda xy.x)(\lambda a.a)(\lambda b.b) \rightarrow_\beta (\lambda ya.a)(\lambda b.b) \rightarrow_\beta \lambda a.a$