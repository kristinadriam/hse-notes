## lecture 11, _28-11-22_

---

### Виртуальный деструктор

Деструкторы сгенерируются автоматически и будут корректно работать.

Но если взять на себя управление выделением/освобождением памяти, то могут возникнуть проблемы. В данном случае int и
string удаляются по-разному, поэтому вызывать delete на объектах типа Printable* некорректно: смотрим на родителя,
вызываем его никак не помеченный деструктор —> поля наследников остались нетронутыми, утечка/UB.

Такое хорошо ловиться санитайзером.

```cpp
struct Printable {  // 'abstract' class because at least one 'pure virtual' function
    virtual void print() const = 0;  // pure virtual
};

struct Int : Printable {
    int x = 0;

    void print() const override {
        std::cout << x << "\n";
    }
};

struct String : Printable {
    std::string s;

    void print() const override {
        std::cout << s << "\n";
    }
};

void print(const Printable &p) {
    p.print();
}

std::vector<Printable*> create_vector() {
    std::vector<Printable*> v;
    Int *i = new Int;
    i->x = 10;
    v.push_back(i);

    String *s = new String;
    s->s = "hello";
    v.push_back(s);
    return v;
}

int main() {
    std::vector<Printable*> v = create_vector();
    for (auto &el : v) {
        print(*el);
    }
    for (auto el : v) {
        delete el;  // UB because incorrect destructor is called; Address Sanitizer, compiler warning
    }
}
```

Решение: делаем деструктор виртуальным: `virtual ~Printable() {};`. Тогда компилятор вызовет нужный деструктор.

```cpp
struct Printable {
    virtual void print() const = 0;
    virtual ~Printable() {};  // !!! VIRTUAL DESTRUCTOR
};

int main() {
    std::vector<Printable*> v = create_vector();
    for (auto &el : v) {
        print(*el);
    }
    for (auto el : v) {
        delete el;  // No UB because virtual destructor is called
    }
}
```

Аналогичная проблема для unique_ptr, только деструктор вызовем не мы.

```cpp
std::vector<std::unique_ptr<Printable>> create_vector() {
    std::vector<std::unique_ptr<Printable>> v;
    std::unique_ptr<Int> i = std::make_unique<Int>();
    i->x = 10;
    v.push_back(std::move(i));

    std::unique_ptr<String> s = std::make_unique<String>();
    s->s = "hello";
    v.push_back(std::move(s));
    return v;
}

int main() {
    std::vector<std::unique_ptr<Printable>> v = create_vector();
    for (auto &el : v) {
        print(*el);
    }
    // UB because incorrect destructor is called; Address Sanitizer, gcc does not warn, clang does warn
}
```

Решение все то же — виртуальный деструктор.

## Многопоточность

### Базовое

На компьютерах может выполняться больше одной программы одновременно. Каждая запущенная программа называется
*процессом*. Внутри каждого процесса бывает один или несколько *потоков выполнения* — кусочков программы, выполняющихся
одновременно с другими кусочками программы.

Чтобы использовать потоки в С++, подключается заголовок `<thread>`.

Создание потока: `std::thread t([&]() { ... });`

Потоки могут получать доступ к переменным друг друга.

`t.join()` — ждет завершения потока и потом очищает ресурсы. Если не вызвать UB.

В конце потока вызывается деструктор, который проверяет, был ли вызван join (join вызывается руками, так как может быть
заморожен на время).

```cpp
#include <thread>

int main() {
    int data = 1234;
    std::thread t([&]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        std::cout << "Hello from thread! data=" << data << "\n";
        data += 10;
    });
    std::cout << "Waiting for it...\n";
    t.join();  // Подождать поток t, освобождает ресурсы потока.
    std::cout << "data is " << data << "\n";
    // Вызывается ~thread(), к этому моменту обязательно сделать join().
}
```

Можно запускать потоки с обычной функцией (без лямбды), можно передавать с параметрами. При этом ссылки передаются
по-особенному: `std::ref(a)` (иначе траблы, вдруг переменная была локальной или что-то такое).

```cpp
void worker(int a, int &b) {
    std::cout << "Thread: " << a << " " << &b << "\n";
}

int main() {
    int a = 10, b = 20;
    std::thread(worker, a, std::ref(b)).join();
}
```

В С++ можно делать `t.detach()` — обещаем больше не делать `join()`, теперь ОС отвечает за сборку мусора в потоке.
Возникает тогда, когда нам ничего от потока не нужно, то есть не важно, что делает поток и когда он завершится.

Но нужно гарантировать, что программа завершится после завершения всех потоков, иначе — UB.

```cpp
int main() {
    int data = 1234;
    std::thread t([&]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        std::cout << "Hello from thread! data=" << data << "\n";
        data += 10;
    });
    std::cout << "Detaching...\n";
    t.detach();  // Обещаем больше не делать join(), теперь ОС отвечает за сборку мусора в потоке.
                 // Возникает только если нам вообще ничего от потока `t` никогда не будет нужно.
                 // Единственный разумный пример: мы создаём сетевой сервер, который в бесконечном цикле плодит потоки для клиентов.
    std::cout << "data is " << data << "\n";
    // После завершения main() завершается программа, но поток всё ещё работает — UB (обращения к умершим глобальным переменным).
    return 0;
}
```

Пример параллельного подсчета:

```cpp
std::vector<unsigned> results;

void worker(int begin, int end, int t) {
    unsigned sum = 0;
    for (int i = begin; i < end; i++) {
        sum += i * i / 2;
    }
    results[t] = sum;
}

int main() {
    const int N = 1'000'000'000;
    const int K = 3;

    auto start = std::chrono::steady_clock::now();

    std::vector<std::thread> ts;
    results.resize(K);
    for (int i = 0; i < K; i++) {
        std::thread t(worker, N * i / K, N * (i + 1) / K, i);
        ts.emplace_back(std::move(t));  // note: std::thread cannot be copied
    }
    for (auto &t : ts) {
        t.join();
    }

    unsigned result = 0;
    for (auto r : results) {
        result += r;
    }
    std::cout << result << "\n";
    std::cout << "Elapsed "
              << std::chrono::duration_cast<std::chrono::milliseconds>(
                     std::chrono::steady_clock::now() - start
                 )
                     .count()
              << "ms\n";
}
```

### Взаимодействие потоков

Работает.

```cpp
void writeln(const std::string &s) {
    for (std::size_t i = 0; i < s.size(); i++) {
        std::cout << s[i];
    }
    std::cout << '\n';
}

int main() {
    for (;;) {
        writeln("Hello from the main thread");
    }
}
```

Плохо работает, символы выводятся рандомно.

```cpp
void writeln(const std::string &s) {
    for (std::size_t i = 0; i < s.size(); i++) {
        std::cout << s[i];
    }
    std::cout << '\n';
    // std::cout << s << "\n";
}

int main() {
    std::thread t([]() {
        for (;;) {
            writeln("Hello from the second thread");
        }
    });
    for (;;) {
        writeln("Hello from the main thread");
    }
}
```

То есть все проблемы возникают из-за того, что потоки работают одновременно. Ровно как и бонусы :)

### Mutex

Методы борьбы — *примитивы синхронизации*.

`std::mutex` — *MUTual EXclusion* (лежит в `<mutex>`)—> две операции, `lock()` и `unlock()`. Поток может захватывать
только кто-то один одновременно.

Например, можно (вернее даже сказать “нужно”) сделать глобальный mutex, который будет захватывать вывод на экран.

`std::yeild` —> костыль, уступка кому-нибудь другому.

```cpp
#include <mutex>

std::mutex m;
void writeln(const std::string &s) {
    m.lock();
    for (std::size_t i = 0; i < s.size(); i++) {
        std::cout << s[i];
    }
    std::cout << '\n';
    m.unlock();
}

int main() {
    std::thread t([]() {
        for (;;) {
            writeln("Hello from the second thread");
            std::this_thread::yield();  // Костыль!
        }
    });
    for (;;) {
        writeln("Hello from the main thread");
        std::this_thread::yield();
    }
}
```

Как ошибиться — сделать локальный `mutex`.

`lock()` для mutex делается один раз, для второго будет ожидание освобождения.

```cpp
void writeln(const std::string &s) {
    std::mutex m;
    m.lock();
    for (std::size_t i = 0; i < s.size(); i++) {
        std::cout << s[i];
    }
    std::cout << '\n';
    m.unlock();
}
```

### Unique_lock

Если `unlock()` забыли или поток упал, то все упало, все потоки подвисли... —>

`std::unique_lock m1{m}` —> автоматически сделал и `lock()`, и `unlock()`.

```cpp
std::mutex m;
void writeln(const std::string &s) {
    std::unique_lock l{m};
    for (std::size_t i = 0; i < s.size(); i++) {
        std::cout << s[i];
    }
    std::cout << '\n';
}
```

### Байки про многопоточность

- src

    ```cpp
    #include <iostream>
    #include <thread>
    
    #pragma GCC optimize ("O0")
    
    const int N = 500'000'000;
    const int M = 1000;
    
    int main() {
        int data = 0;
        auto worker = [&]() {
            for (int i = 0; i < N; i++) {
                data++;
            }
        };
        std::thread t(worker);
        for (int i = 0; i < M; i++) {
            std::cout << "data is " << data << " (in progress)\n";
        }
        t.join();
        std::cout << "data is " << data << "\n";
        return 0;
    }
    ```

Выводим только четные… Или нет? —> сначала проверяется условие, а потом выводится уже измененное значение.

- src

    ```cpp
    #include <iostream>
    #include <thread>
    
    #pragma GCC optimize ("O0")
    
    const int N = 500'000'000;
    const int M = 1000;
    
    int main() {
        int data = 0;
        auto worker = [&]() {
            for (int i = 0; i < N; i++) {
                data++;
            }
        };
        std::thread t(worker);
        for (int i = 0; i < M; i++) {
            if (data % 2 == 0) {
                std::cout << "data is " << data << " (in progress)\n";
            }
        }
        t.join();
        std::cout << "data is " << data << "\n";
        return 0;
    }
    ```

Можно считывать в локальную переменную.

- src

    ```cpp
    #include <iostream>
    #include <thread>
    
    #pragma GCC optimize ("O0")
    
    const int N = 500'000'000;
    const int M = 1000;
    
    int main() {
        int data = 0;
        auto worker = [&]() {
            for (int i = 0; i < N; i++) {
                data++;
            }
        };
        std::thread t(worker);
        for (int i = 0; i < M; i++) {
            int data_snapshot = data;
            if (data_snapshot % 2 == 0) {
                std::cout << "data is " << data_snapshot << " (in progress)\n";
            }
        }
        t.join();
        std::cout << "data is " << data << "\n";
        return 0;
    }
    ```

Два потока —> data++ — это три операции: считать, увеличить, записать.

- src

    ```cpp
    #include <iostream>
    #include <thread>
    
    #pragma GCC optimize ("O0")
    
    const int N = 500'000'000;
    const int M = 10'000;
    
    int main() {
        int data = 0;
        auto worker = [&]() {
            for (int i = 0; i < N; i++) {
                data++;
            }
        };
        std::thread t1(worker);
        std::thread t2(worker);
        for (int i = 0; i < M; i++) {
            int data_snapshot = data;
            if (data_snapshot % 2 == 0) {
                std::cout << "data is " << data_snapshot << " (in progress)\n";
            }
        }
        t2.join();
        t1.join();
        std::cout << "data is " << data << "\n";
        return 0;
    }
    ```

Можно захватывать значение mutex. Но все еще есть UB — нельзя одновременно делать что-то с переменной одновременно. Даже
читать.

- src

    ```cpp
    #include <iostream>
    #include <mutex>
    #include <thread>
    
    #pragma GCC optimize ("O0")
    
    const int N = 5'000'000;
    const int M = 10'000;
    
    int main() {
        std::mutex m;
        int data = 0;
        auto worker = [&]() {
            for (int i = 0; i < N; i++) {
                std::unique_lock l{m};
                data++;
            }
        };
        std::thread t1(worker);
        std::thread t2(worker);
        for (int i = 0; i < M; i++) {
            int data_snapshot = data;
            // todo: example: copy vector
            if (data_snapshot % 2 == 0) {
                std::cout << "data is " << data_snapshot << " (in progress)\n";
            }
        }
        t2.join();
        t1.join();
        std::cout << "data is " << data << "\n";
        return 0;
    }
    ```

Нужно любой доступ к переменной делать по mutex’у.

- src

    ```cpp
    #include <iostream>
    #include <mutex>
    #include <thread>
    
    #pragma GCC optimize ("O0")
    
    const int N = 5000000;
    const int M = 10000;
    
    // Дополнительное чтение: у clang есть статический анализ: https://clang.llvm.org/docs/ThreadSafetyAnalysis.html
    // Можно пометить int data GUARDED_BY(m); и он много чего проверит.
    
    int main() {
        std::mutex m;
        int data = 0;
        auto worker = [&]() {
            for (int i = 0; i < N; i++) {
                std::unique_lock l{m};
                data++;
            }
        };
        std::thread t1(worker);
        std::thread t2(worker);
        for (int i = 0; i < M; i++) {
            std::unique_lock l(m);
            int data_snapshot = data;
            l.unlock();  // Не m.unlock()! Иначе unique_lock сделает unlock() ещё раз, это UB.
    
            if (data_snapshot % 2 == 0) {
                std::cout << "data is " << data_snapshot << " (in progress)\n";
            }
        }
        t2.join();
        t1.join();
        std::cout << "data is " << data << "\n";
        return 0;
    }
    ```

### Atomic

`std::atomic<int> data` (в `<atomic>`) — атомарные переменные, с ними можно делать какие-то операции без `mutex`’а.

Атомарная операция — такая операция, что не может случиться ситуации, когда мы "вклинились" в середину её выполнения.
Считаем, что ничего не атомарно, если нам явно не сказали обратное.
Например, утверждается, что записать символ в `std::cout` — атомарная операция и мы безопасно можем это сделать.

Но тут все еще плохо.

- src

    ```cpp
    #include <atomic>
    #include <iostream>
    #include <thread>
    
    #pragma GCC optimize ("O0")
    
    const int N = 50'000'000;
    const int M = 10'000;
    
    int main() {
        std::atomic<int> data = 0;
        auto worker = [&]() {
            for (int i = 0; i < N; i++) {
                data = data + 1;
            }
        };
        std::thread t1(worker);
        std::thread t2(worker);
        for (int i = 0; i < M; i++) {
            if (data % 2 == 0) {
                std::cout << "data is " << data << " (in progress)\n";
            }
        }
        t2.join();
        t1.join();
        std::cout << "data is " << data << "\n";
        return 0;
    }
    ```

Можно делать data++, но snapshot все еще нужен.

- src

    ```cpp
    #include <atomic>
    #include <iostream>
    #include <thread>
    
    #pragma GCC optimize ("O0")
    
    const int N = 50'000'000;
    const int M = 10'000;
    
    int main() {
        std::atomic<int> data = 0;
        auto worker = [&]() {
            for (int i = 0; i < N; i++) {
                data++;
            }
        };
        std::thread t1(worker);
        std::thread t2(worker);
        for (int i = 0; i < M; i++) {
            if (data % 2 == 0) {
                std::cout << "data is " << data << " (in progress)\n";
            }
        }
        t2.join();
        t1.join();
        std::cout << "data is " << data << "\n";
        return 0;
    }
    ```

Лучше не использовать atomic..

- src

    ```cpp
    #include <atomic>
    #include <iostream>
    #include <thread>
    
    struct list_node {
        std::atomic<int> value = 0;
        std::atomic<list_node*> next = nullptr;
    };
    
    void insert_after(list_node *n, int new_value) {
        list_node *n2 = new list_node;
        n2->value = new_value;
    
        #if 0
        n2->next = n->next;
        #else
        list_node *n_next = n->next;
        n2->next = n_next;
        #endif
    
        n->next = n2;
    
        // Further reading:
        // 1. Lock-free single linked list.
        // 2. CAS operations
        // 3. ABA problem
    }
    
    int main() {
        list_node head;
        const int N = 1'000'000;
        auto worker = [&]() {
            for (int i = 0; i < N; i++) {
                insert_after(&head, i);
            }
        };
        std::thread t1(worker);
        std::thread t2(worker);
        t1.join();
        t2.join();
        int len = 0;
        for (list_node *p = &head; p; p = p->next)
            len++;
        std::cout << len << "\n";
    }
    ```

Теряются элементы списка: нужно одновременно прочитать, записать, поменять с тремя атомиками одновременно ???

- src

    ```cpp
    
    ```

### Смешные UB

Программа зависает, data = 0 в конце. Оптимизатор считает, что оба while = бесконечный цикл (stop проверяется один раз,
data не меняется вне потока).

- src

    ```cpp
    #include <cassert>
    #include <chrono>
    #include <iostream>
    #include <thread>
    
    #pragma GCC optimize("-O2")
    
    int main() {
        int data = 0;
        bool stop = false;
    
        std::thread t([&]() {
            while (!stop) {  // Hmm: stop is always the same => loop is either infinite or never starts.
                data++;
            }
        });
    
        while (data < 100) {}  // Hmm: data is always the same => loop is either infinite or never starts.
        assert(data >= 100);
        std::cout << "done " << data << "\n";
        stop = true;
    
        // Hmm: optimizations like this are important. The alternative is to always re-read from memory, memory is slow.
    
        t.join();
    }
    ```

Компилятор может поменять строки местами и data окажется непроинициазированной.

- src

    ```cpp
    #include <chrono>
    #include <iostream>
    #include <thread>
    
    #pragma GCC optimize("-O0")
    
    int main() {
        int data = 0;
        bool finished = false;
    
        std::thread t([&]() {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            // Hmm: we can run following two lines in any order, it does not matter.
            data = 123;
            finished = true;
        });
    
        while (!finished) {}
        // Hmm: we assume that `finished = true` is ran after `data = 123`.
        std::cout << data << "\n";
    
        t.join();
    }
    ```

### Volatile

`volatile` (ключевое слово языков C/C++, которое информирует компилятор о том, что значение переменной может меняться из
вне и что компилятор не будет оптимизировать эту переменную.) — для многоточности вообще не помогает. На оптимизации
процессора не влияет.

- src

    ```cpp
    #include <chrono>
    #include <iostream>
    #include <thread>
    
    #pragma GCC optimize("-O2")
    
    int main() {
        volatile int data = 0;
        volatile bool finished = false;
    
        std::thread t([&]() {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            // Hmm: compiler cannot reorder two writes below. But CPU still can!
            data = 123;
            finished = true;
        });
    
        while (!finished) {}
        // Hmm?
        std::cout << data << "\n";
    
        t.join();
    }
    ```

## Параллельные вычисления

### Базовое

```cpp
Появилось только в 1978 году, первые две страницы: https://lamport.azurewebsites.net/pubs/time-clocks.pdf

# Модель параллельных вычислений
Мотивация: есть оптимизации компилятора/процесора и кэши.
Хотим решить, по каким правилам играть.

Бывают даже слабые модели памяти, когда нельзя считать, что "потоки выполняются по очереди": https://habr.com/ru/company/JetBrains-education/blog/523298/

Решение: заводим между событиями отношение happens-before (произошло-до).
Это свойство конкретного выполнения программы(!), а не программы целиком.
Если между А и Б есть отношение, то всё ок, если нет — они произошли "одновременно" независимо от того, что показывают часы на стене (wall clock time).

Базово happens-before возникает:

1. Внутри потока: если `A; B`, то A happened-before B. Плюс ещё некоторые "sequenced-before": https://en.cppreference.com/w/cpp/language/eval_order
2. Создание потока.
3. Между потоками: "отпустили мьютекс M" happens-before "взяли мьютекс M".
4. У atomic'ов: "записали в A" не совсем happens-before "прочитали из A" (есть тонкости с "код должен зависеть от прочитанного значения", но этим почти никто не пользуется).

# Пример хорошего happens-before
```c++
// Thread 1
started = true;
m.lock();
finished = true;
m.unlock();

// Thread 2
m.lock();
//std::cout << started;
if (finished) {
    assert(started);    // Верно
}
m.unlock();
```

Здесь при любом выполнении между записью `finished = true` и чтением `finished`
всегда есть happens-before либо в одну сторону, либо в другую.

Аналогично с записью/чтением `started`.
И мы даже можем делать выводы про совместные значения `finished`/`started`.

# Пример отсутствия happens-before

```c++
// Thread 1
started = true;
m.lock(); data++; m.unlock();
finished1 = true;
finished2 = true;

// Thread 2
m.lock(); m.unlock();
if (finished2) { // UB
assert(finished1);  // Непонятно, UB/reordering
assert(data > 0);   // Непонятно, UB
assert(started);    // Непонятно, UB
}
```

Если сначала выполнился thread 1, а потом thread 2,
то есть запись `started = true` happened-before чтения `started`, что хорошо.
Но нет никакого happens-before между записью `finished2 = true;` и чтением `finished2`.
То есть при чтении `finished2` будет UB и программа дальше UB.

Более того, ни в одном выполнении happens-before для `finished2` не получится,
то есть это UB вообще всегда.

# Мораль

* Не помогает даже `sleep_for`, он не создаёт никакого happens-before!
  Только маскирует проблемы.
* Мьютексы помогают хорошо: если у нас доступ к данным всегда защищён мьютексом, то в любом выполнении можем найти
  happens-before в одну из сторон.
* Можно делать хитрые мьютексы (`shared_mutex`): разрешать либо одного "писателя", либо несколько "читателей"
  одновременно.
  Как в Rust.
* Рекомендация: делайте поменьше общих ресурсов у потоков.

```

---

## 05/12/22

## Массивы в C

### Базовое про массивы

Есть массив `arr[N]` N - константа на этапе компиляции (кроме некоторых исключений).

```cpp
const int N = 5;

int main() {
// "C-arrays", "plain arrays"
[[maybe_unused]] int var1, arr[2 * N], var2;
// 10 uninitialized ints one after another.
// Automatic storage duration
// Size should be a compile-time expression, strictly greater than 0
```

`sizeof(arr) / sizeof(arr[0])` — размер массива.

```cpp
arr[2] = 123;
assert(std::size(arr) == 10);  // C++-style
assert(sizeof(arr) == 10 * sizeof(int));  // C style
assert(sizeof(arr) / sizeof(arr[0]) == 10);  // C style
```

Обращение к несуществующему элементу — UB.

```cpp
// std::cout << arr[10];  // UB
```

Нельзя копировать. Совсем.

```cpp
// No push_back/pop_back/insert/operator==/copying/...
// int arr2[2 * N] = arr;  // Just does not compile
// int arr3[2 * N];
// arr3 = arr;
```

Можно проходиться по элементам при помощи range-based-for.

```cpp
// range-based-for is ok, though
for (int &x : arr) {
x = 10;
}
```

### **Variable Length Array (VLA)**

Можно создать массив неконстантной длины с помощью расширения GCC и Clang.

Отрубается функция `std::size` (sizeof работает).

```cpp
// GCC/Clang extension in C++ (available in C99): Variable Length Array (VLA).
// Not available in other compilers.
// https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html
int n;
std::cin >> n;
int vla[n];  // Allocated "on stack"
std::cout << sizeof(vla) / sizeof(vla[0]) << "\n";
// std::cout << std::size(vla) << "\n";  // Does not compile because there is no exact "type" for VLA to instantiate std::size with.
for (int i = 0; i < n; i++) {
vla[i] = i * i;
}
```

### **Инициализация**

Изначально ничем не проинициализирован.

`a[10] = {}` — автоматически инициализируется 0.

```cpp
[[maybe_unused]] int a1[10];  // 10 default-initialized ints: uninitialized
[[maybe_unused]] std::string a2b[10];  // constructors are still called
[[maybe_unused]] int a2[10] = {};  // value-initialize all elements: 0.
[[maybe_unused]] int a3[10]{};  // same

[[maybe_unused]] int a4[10] = {1, 2, 3};  // value-initialize all elements
                                          // except first three (copy-initialized)
int a5[10]{1, 2, 3};  // same, copy-initialized

[[maybe_unused]] int a6[10] = { 0 };  // 0, 0, 0, 0, ...
[[maybe_unused]] int a7[10] = { 1 };  // 1, 0, 0, 0, ...
[[maybe_unused]] int a8[] = {1, 2, 3};  // size == 3
```

### **Арифметика указателей**

`int *dpr = data` — *array-to-pointer decay* — преобразование массива в адрес на свой первый элемент.

```cpp
int data[] = {1, 2, 3, 4, 5};
int *dptr = data;  // array-to-pointer decay, implicit
```

`*(dpr + 1)` — арифметика, указывает на data[1].

Оператор [] — `dpr[-1] == *(dpr - 1) == -1[dpr]`.

```cpp
&data[0], &data, dptr;  // All the same
*dptr, *(dptr + 2); 
*(dptr - 1), *(dptr + (-1)), dptr[-1], (-1)[dptr];  // 2
```

Можно воспринимать data как итератор — `sort(data, data + 5)`

```cpp
std::sort(std::begin(data), std::end(data));
std::sort(&data[0], &data[4] + 1);
std::sort(data, data + 5);
```

При этом выход зв пределы все еще будет UB.

```cpp
// std::cout << *(dptr - 3) << "\n";  // UB, out of bounds
// std::cout << *(dptr + 3) << "\n";  // UB, out of bounds
```

### **Разыменование**

Нельзя разыменовать указатели в переменные.

```cpp
void print_all(int *beg, int *en) {
		// Just like iterators
		for (int *it = beg; it != en; it++) {
		    std::cout << *it << "\n";
		}
}

int data[]{40, 20, 10, 30};

int *one_past_end = data + 4;
print_all(data, one_past_end);
// int x = *one_past_end;  // dereference is UB.

int *ub1 = data - 1;
int *ub2 = data - 1 + 1;
int *ub3 = data + 5;
int *ub4 = data + 5 - 5;
```

### **Массивы в структурах**

Можно делать массивы полями в структурах. Копировать в структурах можно.

```cpp
const int MAX_N = 10;
struct Points {
    int n;
    int xs[MAX_N];  // Same as if 10 fields are defined.
    int ys[MAX_N];
};

Points a, b;

a.n = 1;
a.xs[0] = 10;
a.ys[0] = 20;

b = a;  // Can reassign structs with arrays inside.
```

### **Выделение массива на куче**

Если нужен массив большого размера — использовать оператор `new[]`  и `delete[]`.

```cpp
std::string *strs = new std::string[n];  // Array of 'n' std::string's,
// Heap-allocated, dynamic storage duration.
// Also possible: std::unique_ptr<std::string[]>, shared_ptr<std::string[]>
// Note [] so they call delete[] instead of delete.
// Better, although adds level of indirection: shared_ptr<vector<string>>

strs[0] = "hello world, this is the first string in the array";
strs[1] = std::string(1000, 'x');
for (int i = 0; i < n; i++) {
    std::cout << i << ": " << strs[i] << "\n";
}
delete[] strs;  // delete[], not just delete!

// Inferior to std::vector, please never use.
```

### **Получение С-массива из вектора**

```cpp
void print_all(int *beg, int *en) {
    // Just like iterators
    for (int *it = beg; it != en; it++) {
        std::cout << *it << "\n";
    }
}

std::vector<int> vec(10);
// Requires non-empty vec
print_all(&vec[0], &vec[0] + vec.size());
print_all(&*vec.begin(), &*vec.begin() + vec.size());
// Works even with empty vec
print_all(vec.data(), vec.data() + vec.size());

std::set<int> s{1, 2, 3};

std::set<int>::iterator it_1 = s.begin();
it_1++;  // ok

// UB:
print_all(&*s.begin(), &*s.begin() + 3);
int *s_it2 = &*s.begin();
s_it2++;  // UB
```

### **Передача массива в качестве аргумента**

`int *arr` — может быть указатель на int, а может быть и массивом. Решительно неясно.

Лучше, когда в функции передают указатель на начало и размер массива!

```cpp
// void foo(int arr[]) {  // Actually void foo(int *arr)
// void foo(int arr[5]) {  // Actually void foo(int *arr)
void foo(int arr[15]) {  // Actually void foo(int *arr)
// void foo(int *arr) {
// Careful: sizeof pointer
std::cout << "arr[0] = " << arr[0] << ", sizeof = " << sizeof(arr) << "\n";
}

void foo_good(int arr[], int arr_len) {
std::cout << "arr[0] = " << arr[0] << ", len = " << arr_len << "\n";
// foo_good(arr, sizeof arr / sizeof arr[0]);  // bad as well
foo_good(arr, arr_len);  // ok
}
```

## Строки в C

### C-style string / null-terminated string / ASCIIZ string

Строка = массив символов `char str[]`, в котором последний символ имеет код 0 (`0` или `‘\0’`).

```cpp
// C-style string / строки в стиле си / сишные строки
// null-terminated string
// ASCIIZ string

/*const*/ char str[] = "hello";  // const is optional: we're copying "hello" into a local array with automatic storage duration.
// char str[] = {'h', 'e', 'l', 'l', 'o', 0};
```

`std::size(str)` и `sizeof(str) / str[0]` —> длина строки + 1.

```cpp
std::strlen(str);  // 5
std::size(str);  // 6
sizeof(str) / sizeof(str[0]);  // 6
```

`char *` в С++ трактуется именно как С-строка, а не массив char’ов —> могут быть проблемы, когда нужен именно массив.

Все еще есть преобразование из строки-массива в указатель.

`const char *` — указатель на начало строки, не строка.

```cpp
const char *str_ptr = str;  // array-to-pointer decay
// std::cout << std::size(str_ptr) << "\n";  // does not compile

std::cout << static_cast<const void*>(str_ptr) << "\n";
std::cout << str << "\n";  // decay

const char *str_ptr2 = &str[2];
std::cout << str_ptr2 << "\n";

const char strs[] = "hello\0world\0botva";
std::cout << std::size(strs) << "\n";  // 18
std::cout << strs << "\n";
std::cout << &strs[1] << "\n";
std::cout << &strs[6] << "\n";
std::cout << &strs[12] << "\n";

std::string cpp_str_1 = "hello\0world";  // initialization from C string
std::cout << cpp_str_1 << " " << cpp_str_1.size() << "\n";

std::string cpp_str_2 = "hello";
cpp_str_2 += '\0';
cpp_str_2 += "world";
std::cout << cpp_str_2 << " " << cpp_str_2.size() << "\n";
```

UB <— не найден 0 в конце.

```cpp
char a = 'x';
char *a_str_bad = &a;
char b[2] = "hi";

std::cout << a_str_bad << "\n";  // ub: out of bounds
std::cout << b << "\n";  // ub: out of bounds
```

### **Сравнение строк**

Можно сравнивать с помощь ‘<’, если указатели из одного массива. Если из разных, то это unspecified behaviour.

Если положить в конец 0, то неясно, какой это 0.

Правильное сравнение — через `for` или через `strcmp()` —> возвращает или 0, или число больше 0, или число меньше 0, не
+-1.

```cpp
{
    const char *s = "hello";
    const char *a = s;  // hello
    const char *b = s + 1;  // ello
    std::cout << (a < b) << "\n";  // Not UB: 'a' and 'b' are in the same array.
}
{
    const char *a = "hello";
    const char *b = "ello";
    std::cout << (a < b) << "\n";  // unspecified behavior, may be inconsistent.
}
{
    const char *a = "hello";
    const char *b = "hello\0";
    std::cout << (a == b) << "\n";  // Unknown result, not UB.
}
{
    const char *a = "hello";
    const char *b = "hello\0";
    bool eq = true;
    for (int i = 0; a[i] || b[i]; i++)
        if (a[i] != b[i]) {
            eq = false;
            break;
        }
    std::cout << eq << "\n";
}
{
    const char *a = "hello";
    const char *b = "world";
    // not necessarily +-1. May be +12437.
    // mnemonics: sign(a - b)
    std::cout << std::strcmp(a, b) << "\n";
    std::cout << std::strcmp(a, "hello\0botva") << "\n";  // Always 0.
}
}
```

### **Длина строки**

За линию. Функция `strlen()` тоже за линию.

```cpp
int botva[10];

bool has_a(const char *str) {
//    for (std::size_t i = 0; i < std::strlen(str); i++) {
//    for (std::size_t i = 0, len = std::strlen(str); i < len; i++) {
    for (std::size_t i = 0; str[i]; i++) {
        if (str[i] == 'a') {
            return true;
        }
        botva[0] = 123;
    }
    return false;
}

int main() {
    {
        const char *a = "hello";
        int len = 0;
        while (a[len]) {
            len++;
        }
        std::cout << len << "\n";
        std::cout << std::strlen(a) << "\n";
    }
}
```

### Выделение памяти для строк

Можно писать функции, выделяющие память, которые в конце необходимо будет очистить память самостоятельно —> сложно
отслеживать.

```cpp
const char *strcat_alloc(const char *a, const char *b) {  // It's not like std::strcat, the latter does not allocate memory at all.
    char *res = new char[std::strlen(a) + std::strlen(b) + 1];

    int res_len = 0;
    for (int i = 0; a[i]; i++)
        res[res_len++] = a[i];
    for (int i = 0; b[i]; i++)
        res[res_len++] = b[i];
    res[res_len] = '\0';
    return res;
}

int main() {
    const char *x = "xyz";
    const char *y = strcat_alloc("xy", "z") + 1;
    // ......
    delete[] (y - 1);
}
```

### **Считывание строк**

Функция `readWord`. Не проверяет, не вышли ли мы за границы массива. Небезопасно + нужно следить за размером буфера.

```cpp
#include "optimization.h"

int main() {
    const int MAX_LEN = 10;
    char buf[MAX_LEN + 1];
    bool is_password_correct = false;
    readWord(buf);  // Careful: do not overflow the buffer
                    // UB otherwise, see https://en.wikipedia.org/wiki/Buffer_overflow
                    // Solution: do not use 'readWord', use 'fgets' instead of 'gets'
                    // Also see https://ulearn.me/Course/Hackerdom
}
```

Функция gets. UB для длинных строк. Поэтому использовать не рекомендуется. Функции, не принимающие размер массива, —
подозрительные…

```cpp
int main() {
    const int MAX_LEN = 10;
    char buf[MAX_LEN + 1];
    gets(buf);  // DANGEROUS
    std::cout << "buf=|" << buf << "|\n";
    // Top-1 vulnerability: https://ulearn.me/course/hackerdom/Perepolnenie_steka_3bda1c2c-c2a1-4fb0-9146-fccc47daf93b
}
```

Если более аккуратно, то `fgets()`.

```cpp

printf("> ");

char command[10];
// Мы за безопасный gets!
fgets(command, sizeof command, stdin);  // Always null-terminated string, truncated.

// C++'s std::string never truncates, but may exhaust whole memory.

printf("command is |%s|\n", command);
```

### **String dangling**

`c_str()` — указатель на внутренний буффер string. После удаления s, s_ptr указывает на очищенную память —> UB, которое
стреляет не всегда (например, из-за small string optimization).

```cpp
const char *s_ptr;
{
    // Small string optimization
    // std::string s = "hello";
    std::string s = "hello 1234567890654345678986434567898643456789097654";

    s_ptr = s.c_str();
    // s_ptr = &s[0];
}
{
    char x[] = "botva1234565436543654654387658746";
    std::cout << x << "\n";
}
```

## Библиотеки в С

### Базовое

- about

    ```cpp
    C APIs may seem complicated. It is because:
    
    1. They use C and fully manual resource management.
       E.g. no methods grouped for an object, functions are intermingled in docs, lots of void*, lack of `const`.
       E.g. a buffer is user-allocated and is two arguments: the pointer and the length.
    2. They rarely interoperate with each other.
       E.g. there may be a "dynamic string/array" library and a separate
       "file reading"/"network sockets" library which only knows about C
       with fixed-size buffers.
    3. They are very low-level for the domain, although there may be "convenience wrappers".
       Lots of options, all cases of the domain are covered.
       Any interface may be wrong, convoluted or both.
       E.g.: do not use these functions: https://www.openssl.org/docs/man1.1.1/man3/SHA256.html
    4. There may be lots of "flags", bit-fiddling, data packing, little type checks.
       Not a beautiful `enum`, but just `int`/`long` (be careful) and a bunch of
       consts which you have to find in the code.
       E.g. `fopen("a.txt", "r")`, `printf("hello=%d", 123)`
       E.g. https://curl.se/libcurl/c/curl_easy_setopt.html
    5. Anything can err, should be handled.
       In C++ we just don't think about it as much => surprising exceptions or silent failures (like with `iostream`).
    
    How to use:
    
    0. Try find library in C++, otherwise:
    1. Try to find a "convenience wrapper" or "simple interface".
    2. Try to find a full official example: https://curl.se/libcurl/c/example.html
    3. DO NOT try to call random functions without reading docs/manpages.
    
    Convention:
    
    * (Almost) everything can be either zero-initialized with `memset` or have a dedicated initialization function.
    * (Almost) everything can be copied/moved bytewise with `memcpy`.
    * Memory and buffers are either:
      * Fully (de)allocated by the user (strings)
      * Fully (de)allocated by the library (see next example).
    ```

### **Void ***

Передача произвольных данных функций (например, потому что нет перегрузок, а данные могут быть различны).

`void *` — базовый указатель на все на свете, указатель куда-то в память.

Арифметика по стандарту не компилируется, но gcc и clang сделали расширение — на 1 байт.

```cpp
#include <cassert>

// "Library"
void *user_data;

//todo: like setopt
void set_data(void *data) {
    user_data = data;
}

void *get_data() {
    return user_data;
}

// Somewhat like std::any

// Application
int main() {
    int data[]{1, 2, 3, 4};

    set_data(data);  // implicit: int[4] --> int* --> void*
    int *data_ptr = static_cast<int*>(get_data());
    assert(data_ptr[2] == 3);
}
```

### Const cast

Какая-то древняя ничего не меняющая функция принимает char *, а нужно передать const char *, что
делать? —> `const_char<char *>(s)`. Если попытать после этого поменять s, то будет UB.

```cpp
int len(char *s) {
    int l = 0;
    while (s[l] != '\0') {
        l++;
    }
    return l;
}

void update(char *s) {
    s[0] = 'h';
}

int main() {
    const char *s = "hello";
    // assert(len(s) == 5);  // compilation error
    assert(len(const_cast<char*>(s)) == 5);  // ok

    update(const_cast<char*>(s));  // ub
}
```

### **Непрозрачные указатели (opaque pointer)**

`FILE *` — не лезь, убьет..

```cpp
#include <stdlib.h>
#include <stdio.h>

int main() {
    // "opaque" pointer
    FILE *f = fopen("02-opaque-pointers.c", "r");  // "constructor", resources are allocated by the library.

    // Never try to access `FILE`'s fields directly.
    char buf[20];
    fscanf(f, "%20s", buf);  // "method"
    printf("buf=|%s|\n", buf);

    fclose(f);  // "destructor"
}
```

---

## 12/12/22

## Функции

### Перегрузки функций

Функции в одном `namespace` можно перегружать, одно имя — разные параметры.

Компилятор начинает выбор перегрузки, разрешение перегрузки.

Иногда непонятно, какую функцию выбрать — не компилируется.

```cpp
void println(int x) {
    std::cout << x << "\n";
}

void println(double x) {
    std::cout << x << "\n";
}

void println(const std::vector<int> &vec) {
    std::cout << "{";
    bool first = true;
    for (const auto &item : vec) {
        if (!first) {
            std::cout << ", ";
        }
        first = false;
        std::cout << item;
    }
    std::cout << "}\n";
}

println(10);
println(1.2);
println(std::vector{1, 2, 3});
//    println(123456789123456);
println(1LL);
```

### Неоднозначности перегрузок

**Проблема с NULL**

`NULL` (канонично — указатель в никуда) — проблема при перегрузке функции, некоторые компиляторы считают `int`’ом.

```cpp
struct node {};

void foo(int) {
    std::cout << "foo(int)\n";
}

void foo(node*) {
    std::cout << "foo(node*)\n";
}

int main() {
    foo(0);
    foo(NULL);
    foo(nullptr);  // C++11
}
```

**Проблема с функциями из библиотек**

Компилятор выбрал стандартную функцию, которая вызывается от `int`’ов.

```cpp
using namespace std;

int gcd(int a, int b) {
    // Ternary operator.
    // Bad stuff happens when two branches are of different types.
    // (some complicate type deduction)
    return b ? gcd(b, a % b) : a;

    /* if (b != 0) {
        return gcd(....);
    } else { 
        return a;
    } */
}

// Since C++17: int std::lcm(int a, int b)
// https://codeforces.com/blog/entry/94896
long long lcm(long long a, long long b) {
    return a / gcd(a, b) * b;
}

int main() {
    std::cout << lcm(1'000'000'000, 1'000'000'001) << "\n";
}
```

### Неименованный аргумент

1. использовать [[maybe_unused]] — `f([[maybe_unused]] int x)`
2. не писать имя аргумента — `f(int)`

```cpp
// [[]] is an 'attribute', since C++17
void foo([[maybe_unused]] int x) {
std::cout << "foo(int)\n";
}

void foo(int x, int) {
std::cout << "foo(int x, int) x=" << x << "\n";
}

void foo(int x, int, int z) {
std::cout << "foo(int x, int, int z) x=" << x << ", z=" << z << "\n";
}
```

### Тэги (type tags)

Костыль. Структура-тэг. Для пометок перегрузок значениями нужных типов. Обычно заканчиваются на `*_tag`.

```cpp
struct comma_separated_tag {};  // Not _t, it's reserved.
struct element_per_line_tag {};  // Not _t, it's reserved.

void println(const std::vector<int> &vec, comma_separated_tag) {
    bool first = true;
    for (const auto &item : vec) {
        if (!first) {
            std::cout << ", ";
        }
        first = false;
        std::cout << item;
    }
    std::cout << "\n";
}

void println(const std::vector<int> &vec, element_per_line_tag) {
    for (const auto &item : vec) {
        std::cout << item << "\n";
    }
}

int main() {
    std::vector<int> v{1, 2, 3};
    // type tags
    println(v, comma_separated_tag{});
    println(v, element_per_line_tag{});
}
```

### Параметры по умолчанию

Можно у функций можно указать у каких-то *последних* аргументов дефолтные значения.

При вызове просто не пишутся аргменты.

```cpp
// K _last_ parameters can be defaulted.
void foo(int x, int y = 10, int z = 20) {
std::cout << "x = " << x << "\n";
std::cout << "y = " << y << "\n";
std::cout << "z = " << z << "\n";
}

void bar(std::vector<int> vec = {
1, 2, 3
}) {
vec.push_back(100);
std::cout << "vec.size() = " << vec.size() << "\n";
}

foo(1);
foo(2, 3);
// foo(2, z=3);  // Python-only, not C++
foo(4, 5, 6);
bar();
```

**Пример перегрузки дефолтных значений**

```cpp
#include <iostream>

void foo(int, int = 10) {
    std::cout << "1\n";
}

void foo(int) {
    std::cout << "2\n";
}

int main() {
    foo(10, 20);
    foo(30);
}
```

## Функтор/функциональный объект

### Базовое

Структура, у которой перегружен `operator()`.

Аккуратно с вызовом и конструктора, и оператора()!!!

```cpp
struct Greater {  // Functor (jargon)/special case of "functional object"
    bool operator()(int a, int b) const {
        return a > b;
    }

    int operator()(int a, int b, int c) const {  // overloads are possible
        return a + b + c;
    }
};

int main() {
    std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8};
    const Greater g;  // 'const' is optional, just to demonstrate const-qualifier
    assert(g.operator()(5, 4));
    assert(!g.operator()(4, 5));
    assert(g(5, 4));
    assert(!g(4, 5));
    assert(Greater().operator()(4, 5));
    assert(Greater()(4, 5));
}
```

Некоторые функции принимают в качестве аргументов функторы. Например, для `sort` оператор должен быть `const`.

```cpp
sort(v.begin(), v.end(), g /* Greater() */);
```

### Использование функторов

**Пример компаратора**

```cpp
struct CloserTo {
    int center;

    bool operator()(int a, int b) const {
        return std::abs(a - center) < std::abs(b - center);
    }
};

sort(v.begin(), v.end(), CloserTo{3});
```

**Пример с set**

Можно передавать компаратор в `set`, которому он нужен, чтобы уметь сравнивать элементы. Лямбды здесь не
работают. `set`'у нужен именно тип.

```cpp
struct Greater {
    bool operator()(int a, int b) const {
        return a > b;
    }
};

int main() {
    std::set<int, Greater> v{1, 2, 3, 4, 5, 6, 7, 8};  // Creates Greater() with default ctor.
}
```

Поменять нельзя, только создать новый с новым компаратором и переприсвоить.

```cpp
struct CloserTo {
    int center;

    bool operator()(int a, int b) const {  // 'const' is important
        return std::abs(a - center) < std::abs(b - center);
    }
};

int main() {
    std::set<int, CloserTo> v1({1, 2, 3, 4, 5, 6, 7, 8}, CloserTo{3});  // Copies CloserTo() inside
    std::set<int, CloserTo> v2({1, 2, 3, 4, 5, 6, 7, 8}, CloserTo{7});
    // v1 = v2;
    // v1 = std::set(v1.begin(), v1.end(), CloserTo{5});
}
```

### Указатель на функцию

`(*)` — указатель на функцию. Так можно передавать любые функции, но не лямбды.

```cpp
bool compare_gt(int a, int b) {
    return a > b;
}

int main() {
    std::set<int, bool(*)(int, int)> v({1, 2, 3, 4, 5, 6, 7, 8}, compare_gt);
}
```

`std::function` — не совсем указатель на функцию, можно считать базовым классом для всех существующих функциональных
обхектов. Можно класть что угодно, даже лямбды. Возвращаемый тип не пишется, работает как `auto`.

Выделяет на куче место для функтора, внутри себя хранит указатель + какие-то виртуальные функции. Похож на `unique_ptr`.

*Type Erasure* — стирание типов.

```cpp
struct CloserTo {
    int center;

    bool operator()(int a, int b) const {
        return std::abs(a - center) < std::abs(b - center);
    }
};

struct BigFunctor {
    long long a, b, c, d, e, f, g, h, i;

    bool operator()(int lhs, int rhs) const {
        return lhs < rhs;
    }
};

int main() {
    [[maybe_unused]] std::function<bool(int, int)> cmp1 = CloserTo();
    std::cout << sizeof(CloserTo) << " " << sizeof(cmp1) << "\n";

    [[maybe_unused]] std::function<bool(int, int)> cmp2 = BigFunctor();
    std::cout << sizeof(BigFunctor) << " " << sizeof(cmp1) << "\n";

    int x = 10;
    [[maybe_unused]] std::function<bool(int, int)> cmp3 = [&](int a, int b) {
        return a + x < b + x;
    };
    std::cout << sizeof(cmp3) << "\n";
    
    // Type Erasure (need basic templates): https://www.youtube.com/watch?v=tbUCHifyT24
}
```

### Передача функторов в качестве аргументов

STL предполагает, что копировать можно как угодно.

Функтор `c` скопировалась внутрь `for_each`, сам `c.index` не поменялся. Принимает по значению.

`for_each` возвращает функтор — так можно узнать, какое состояние у функтора послу выполнение функции. Враппер внутри
себя реализует `operator()`.

```cpp
struct Counter {
    int index = 10;
    void operator()(int value) {
        std::cout << index << " " << value << "\n";
        index++;
    }
};

int main() {
    {
        std::vector<int> v{1, 2, 3, 4};
        Counter c;
        std::for_each(v.begin(), v.end(), c);
        std::cout << "c.index = " << c.index << "\n";  // May be 10
    }
    {
        std::vector<int> v{1, 2, 3, 4};
        Counter c;
        c = std::for_each(v.begin(), v.end(), c);
        std::cout << "c.index = " << c.index << "\n";  // Should be 14
    }
}
```

### Ref-wrapper

`std::reference_wrapper<…>` — ссылка на объект, но ее можно скопировать.

`std::ref(..)` — другой способ копирования.

Можно как угодно вызвать ссылку или объект — вызов враппера равносилен вызову функтора с круглыми скобками.

—> можно передать в функция reference wrapper, а не функтор, тогда функтор поменяется, копироваться не будет.

В отличии от обычной ссылки, враппер можно копировать и менять.

```cpp
struct Counter {
    int index = 10;
    void operator()(int value) {
        std::cout << index << " " << value << "\n";
        index++;
    }
};

int main() {
    {
        Counter c;
        Counter c2 = c;  // copy
        std::reference_wrapper<Counter> cwrap = c;  // copyable reference to c OR raw pointers with operator()
        assert(&cwrap.get() == &c);
        auto cwrap2 = cwrap;  // reference to c
        auto cwrap3 = std::ref(c);  // std::reference_wrapper<Counter>
        auto cwrap4 = cwrap3;

        c(1);  // 10 1
        c(2);  // 11 2
        c2(3);  // 10 3
        c2(4);  // 11 4
        c2(5);  // 12 5
        // std::reference_wrapper implements operator() only in addition to get()
        cwrap(6);  // 12 6
        cwrap(7);  // 13 7
        cwrap2(8);  // 14 8
        cwrap2(9);  // 15 9
        cwrap3(10);  // 16 10
        cwrap3(11);  // 17 11
        cwrap4(12);  // 18 12
        cwrap4(13);  // 19 13

        // Also: std::reference_wrapper<const Counter> and std::cref
    }
    std::cout << "=====\n";
    {
        std::vector<int> v{1, 2, 3, 4};
        Counter c;
        std::for_each(v.begin(), v.end(), std::ref(c));
        std::cout << "c.index = " << c.index << "\n";  // Should be 14
    }
}
```

## Лямбды

### Базовое

Лямбда функция — это синтаксический сахар поверх `struct CloserTo`.

```cpp
sort(v.begin(), v.end(), [=](int a, int b) {  // Can also be: [&], [city_position]
    return std::abs(a - city_position) < std::abs(b - city_position);
});
```

### **Виды захватов**

Каждая лямбда создает свой тип, со своими полями, которые она захватывает (локальные переменные, которые она
захватывает), и operator().

В квадратных скобках пишется

`[ ]` — *ничего* не захватывает.

Имеет доступ ко всем своим полям и к глобальным переменным. Размер маленький, нет внутренних полей.

`[=]` (`[this, local_var]` — явное перечисление) — захват всех используемых переменных *по значению*. Они все копируются
внутрь лямбды, что может быть долго. Поля лямбды не умеют захватывать поля, только `this` целиком.

Лямбда запомнит значение в момент создания, после изменения переменных значение внутри лямбды не изменится. Но при
принимании по значению нельзя менять локальные перменные, по умолчанию `operator()` помечен  `const`.

Указатель `this` поменять нельзя, а `*this` можно поменять.

`mutable` — по умолчанию`operator()`у лямбды помечен`const`: она не может менять свои поля (то есть захваченные
значения). Можно добавить слово`mutable`, тогда этот `const` уберётся. Так делают довольно редко, обычно лямбды делают
без состояния.****

`[&]` — захват всего по ссылке (кроме `this`).  `operator()` все еще константная. Теперь переменные меняются вне лямбд.
Если лямбду вызвать после того, как умерли ее захваты, получится висячая ссылка.

`[a = b], [a = a]`(С++14) — создание новой переменной`a`внутри лямбды, инициализация выражением`b`. Имя`a`может совпадат
с именем локальной переменной.

`[&a = b]`(С++14) — создание новой ссылки`a`внутри лямбды, привязанной к выражению`b`. Имя`a`может совпадат с именем
локальной переменной.

Поля захватываются только вместе с`this`/`*this`(если только не написать через`x = x`). Из`[=]`и`[&]`следует`[this]`(
если он используется).****

`[&local_var - std::as_const(local_var)]` — захват по константной ссылке.

Также можно комбинировать несколько захватов, для каждой используемой переменной выберется наиболее
специфичный:`[&, a, &b = c, *this]`

```cpp
struct Foo {
    int member_var = 10;
    static inline int static_member_var = 20;
    int arr[10'000];

    void method() {
        int local_var = 30;
        static int static_local_var = 40;
        [[maybe_unused]] long long local_big[100]{};

        // 1
        auto lambda1 = []() {
            // Not captured.
            // [[maybe_unused]] int x = member_var;
            // [[maybe_unused]] int y = local_var;
            // Never captured, always available.
            static_member_var++;
            static_local_var++;
        };
        lambda1();
        std::cout << "sizeof(lambda1) == " << sizeof(lambda1) << "\n";
        assert(static_member_var == 21);
        assert(static_local_var == 41);

        // 2
        std::cout << "before lambda 2: " << &member_var << " " << &local_var << "\n";
        auto lambda2 = [=]() {  // [this, local_var]
            std::cout << "in lambda 2    : " << &member_var << " " << &local_var << "\n";
            assert(member_var == 10); // this->member_var: reference!
            assert(local_var == 30);
            // assert(local_big[0] == 0);  // Not captured, as unused.
            // operator() is const by default.
            member_var++;  // this is const, but *this is not.
            // local_var++;
        };
        local_var++;  // Do not affect lambda2().
        lambda2();
        local_var--;
        std::cout << "sizeof(lambda2) == " << sizeof(lambda2) << "\n";

        // 3
        auto lambda3 = [=]() mutable {  // [this, local_var]
            // operator() is non-const now.
            member_var++;
            local_var++;
            std::cout << "in lambda 3: local_var new = " << local_var << "\n";
        };
        lambda3();
        std::cout << "sizeof(lamda3) == " << sizeof(lambda3) << "\n";
        assert(member_var == 12);  // Changed.
        assert(local_var == 30);  // Unchanged.

        // 4
        [&]() {  // [this, &local_var]
            // operator() is still const, but these two work.
            member_var++;  // this->member_var, this is const.
            local_var++;  // local_var is a reference, the reference itself is always const.
        }();
        assert(member_var == 13);
        assert(local_var == 31);

        // 5
        std::cout << "before lambda 5: " << &member_var << " " << &local_var << "\n";
        auto lambda5 = [=, *this]() mutable {  // C++17: [*this, local_var]: full copy of '*this', including unused 'arr'.
            std::cout << "in lambda 5    : " << &member_var << " " << &local_var << "\n";
            assert(member_var == 13); // 'this' is fully copied.
            assert(local_var == 31);
            member_var++;
            local_var++;
        };
        lambda5();
        std::cout << "sizeof(lambda5) == " << sizeof(lambda5) << "\n";
        assert(member_var == 13);  // Unchanged.
        assert(local_var == 31);  // Unchanged.

        // 6
        [wtf = local_var + member_var]() {  // C++14
            assert(wtf == 44);
        }();
        [local_var = local_var * 2]() {
            assert(local_var == 62);
        }();
        assert(local_var == 31);

        // 7
        [&local_var = local_var]() {  // Shortcut: [&local_var] (even in C++11)
            assert(local_var == 31);
            local_var++;
        }();
        assert(local_var == 32);
        [&local_var = std::as_const(local_var)]() {
            assert(local_var == 32);
            // local_var++;  // const int &local_var;
        }();
        assert(local_var == 32);
    }
};
```

### Тип лямбд

У всех лямб свой тип. Даже если они одинаковы, типы будут разными. Если нужны лямбды содного типа, то придется писать
свою структуру с `operator()`.

```cpp
auto l1 = [](int a, int b) { return a > b; };
auto l2 = [](int a, int b) { return a > b; };
std::set<int, decltype(l1)> s1(l1);
// std::set<int, decltype(l1)> s2(l2);
```

### Рекурсия лямбд

Рекурсии нет. Внутри лямбды нельзя назвать лямбду.

```cpp
auto fib = [&](int n) {
    if (n <= 1) return n;
    // Compilation error: type of lambda depends on its captures => cannot capture fib.
    return fib(n - 1) + fib(n - 2);
};
```

Можно написать `std::function<int(int)>`. Но это вызов виртуальной функции (очень дорого).

```cpp
std::function<int(int)> fib = [&](int n) {
    if (n <= 1) return n;
    // Careful: calls to virtual functions!
    return fib(n - 1) + fib(n - 2);
};
```

Дешевле — писать `operator()`.

```cpp
int operator()(int n) {
    if (n <= 1) return n;
    return operator()(n - 1) + operator()(n - 2);
    // return (*this)(n - 1) + (*this)(n - 2);
}
```

## Extra

### Псевдонимы типов

Два способа переопределить имя типа — `typedef` и `using`. Разница только на этапе компиляции. Еще можно `#define` (
категорически против, плевать на namespace, зависимости и прочее).

```cpp
typedef std::vector<int> vi;
using pii = std::pair<int, int>;
// Please do not #define: it does not respect namespaces/private/public
// https://stackoverflow.com/a/1666375/767632
```

### Наследование с виртуальными функциями, подхвохи

Вызывать виртуальные функции в конструкторах — плохо. Вызывается сначала функция из родителя, потом из наследника, то
есть вызывается не только самая вложенная функция. У базового класса вызовется только его функция. Аналогично для
деструктора.

```cpp
#include <iostream>

struct Base {
    int value = 123;

    virtual void foo() {
        std::cout << "foo(" << value << ")\n";
    };

    Base() {
        foo();
    }

    ~Base() {
        foo();
    }
};

struct Derived : Base {
    int value2 = 456;

    void foo() override {
        std::cout << "foo(" << value << ", " << value2 << ")\n";
    }

    Derived() : Base(), value2(100) {
        foo();
    }

    ~Derived() {
        foo();
    }
};

int main() {
    Derived d;
    std::cout << "== constructed ==\n";
    d.foo();
    static_cast<Base &>(d).foo();
    std::cout << "== foo called ==\n";
}
```

Не использовать в конструкторах…

```cpp
#include <iostream>

struct Base {
    int value = 123;

    virtual void printTo() = 0;

    Base() {
        printTo();
    }
};

/*void Base::printTo() {  // BUT WHY
    std::cout << "Not so pure, eh?\n";
}*/

struct Derived : Base {
    void printTo() override {
    }
};

int main() {
    // Base b;  // class is still abstract.
    Derived d;
}
```

### Парадокс круга-эллипса.

Что от кого наследовать? Одно является частным случаем другого:

1. **Эллипс —> круг**

Если у элипса есть ширина-высота, то понятно, как считать тоже самое у круга (+ добавиться еще и радиус).

```cpp
// https://isocpp.org/wiki/faq/proper-inheritance

// OK
struct Ellipse {
virtual int width();
virtual int height();
};

struct Circle : Ellipse {  // 'is-a' relationship
int width() override {
return 2 * radius();
}
int height() override {
return 2 * radius();
}
virtual int radius();
};
```

В обратную сторону — неясно.

```cpp
// WTF
struct Circle {
virtual int radius();
};

struct Ellipse : Circle {
int radius() override {
? ? ? ? ? ? ? ? ? ? ? ? ?
}
virtual int width();
virtual int height();
};
```

Попробуем так отнаследовать. Добавим эллипсу методы для установления высоты и установления ширины. Но тогда `foo()` для
круга работать не будет (меняется ширина и высота)!

```cpp
// WTF
struct Ellipse {
virtual int width();
virtual int height();
virtual void setWidth(int w);
virtual void setHeight(int h);
};

void foo(Ellipse &e) {
// LSP violation:
// https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8_%D0%91%D0%B0%D1%80%D0%B1%D0%B0%D1%80%D1%8B_%D0%9B%D0%B8%D1%81%D0%BA%D0%BE%D0%B2
e.setWidth(10);
e.setHeight(20);
assert(e.width() == 10);
assert(e.height() == 20);
}

struct Circle : Ellipse {
void setWidth(int w) override {
setRadius(w / 2);  // ???
}
virtual int radius();
virtual void setRadius(int r);
};
```

1. **Круг —> эллипс**

…тогда удобно сделать так:

```cpp
// OK
struct Circle {
virtual void setRadius(int r);
};

struct Ellipse : Circle {
void setRadius(int r) override {
setWidth(2 * r);
setHeight(2 * r);
}
virtual void setWidth(int w);
virtual void setHeight(int h);
};
```

Получилось нарушение *принципа подстановки Барбары Лисков*: если что-то работает для эллипса, то должно работать и для
круга-наследника.

Вывод: если мы только читаем, то выгодно одним способом. Если пишем — другим способом.

> *Поэтому неважно, что происходит в жизни, важно, что происходит в коде.*
>

---